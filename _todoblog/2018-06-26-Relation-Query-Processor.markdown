---
layout: post
title: (译)Relation Query Processor
date: 2018-06-26 22:06
header-img: "img/head.jpg"
categories: jekyll update
tags:
typora-root-url: ../../yummyliu.github.io
---

前面的章节强调了 DBMS 宏观架构设计问题。本章开始以
关系查询处理器采用声明性 SQL 语句, 对其进行验证, 将其优化为过程数据流执行计划, 并 (受许可控制) 代表客户端程序执行该数据流程序。然后, 客户端程序提取 ("拉") 结果元组, 通常是一次或小批处理。关系查询处理器的主要组件如图1.1 所示。在本节中, 我们关注的是查询处理器和存储管理器的访问方法的一些非事务性方面。通常, 关系查询处理可以看作是单用户单线程任务。如第5节所述, 并发控制由系统的较低层透明地管理。此规则的唯一例外是, 当 DBMS 在操作时必须显式 "pin" 和 "脱离" 缓冲池页, 以便它们在简短的、关键的操作中保持驻留在内存中, 正如我们在4.4.5 节中讨论的那样。
在本节中, 我们将重点讨论常见的 SQL 命令: 数据操作语言 (DML) 语句, 包括选择、插入、更新和删除。数据定义语言 (DDL) 语句 (如创建表和创建索引) 是查询优化器未处理的典型。这些语句通常是通过对存储引擎和目录管理器的显式调用 (在 Sec 6.1 中描述) 在静态 DBMS 逻辑中实现的。有些产品已经开始优化 DDL 语句的一个小子集, 我们预计这一趋势将继续下去。



4.1 查询分析和授权

 给定 sql 语句, sql 分析器的主要任务是 (1) 检查是否正确指定了查询, (2) 解析名称和引用, (3) 将查询转换为优化程序使用的内部格式, (4) 验证用户是否被授权执行查询。有些 DBMSs 将部分或全部安全检查推迟到执行时间, 但即使在这些系统中, 分析器仍负责工程执行时安全检查所需的数据。 给定 SQL 查询, 分析器首先考虑 from 子句中的每个表引用。它将表名 canonicalizes 为表单 [server.database.schema.table](https://ssl.microsofttranslator.com/bv.aspx?from=&to=zh-CHS&a=server.database.schema.table) 的完全限定名。这也称为四部件名。不支持跨多个服务器的查询的系统只需要规范化到 database.schema.table, 并且每个 DBMS 只支持一个数据库的系统只能规范化架构. 表。此规范化是必需的, 因为用户具有与上下文相关的默认值, 允许在查询规范中使用单个部件名。某些系统支持表的多个名称 (称为表别名), 并且必须用完全限定的表名替换它们。 在 canonicalizing 表名之后, 查询处理器会调用目录管理器来检查表是否已在系统编录中注册。在这一步中, 它还可以缓存有关内部数据查询数据结构中表的元数据库。根据有关该表的信息, 它将使用目录来确保属性引用是正确的。属性的数据类型用于驱动重载函数表达式、比较运算符和常量表达式的 ambiguation 逻辑。例如, 考虑一下意境 (EMP. 薪资 * 1.15) 75000。乘法函数和比较运算符的代码以及字符串 "1.15" 和 "75000" 的假定数据类型和内部格式将取决于 EMP 的数据类型. 工资属性。此数据类型可以是整数、浮点数字或 "货币" 值。还应用了其他标准 SQL 语法检查, 包括对元组变量的一致使用、通过 set 运算符组合的表的兼容性 (联合/交集/除)、属性在选择聚合查询列表中的用法、子查询的嵌套, 等等。 如果查询成功分析, 则下一阶段是 authoriza 检查, 以确保用户对表、用户定义的函数或查询中引用的其他对象具有适当的权限 (选择/删除/插入/更新)。在语句分析阶段, 某些系统每窗体完全授权检查。然而, 这并不总是可能的。例如, 支持行级安全性的系统在执行时间之前无法进行完全安全检查, 因为安全检查可以依赖于数据值。即使在理论上可以在一套唱片时间对授权进行静态验证, 延迟一些此项工作以查询计划执行时间也有好处。将安全检查推迟到执行时间的查询计划可以在用户之间共享, 并且在安全更改时不需要重新编译。因此, 某些部分的安全 idation 通常会推迟到查询计划执行。 在 compi 过程中, 也有可能约束-检查常量表达式。例如, UPDATE 命令可能具有 "EMP" 窗体集的子句. 薪水 =-1。如果完整性约束指定工资的正值, 则甚至不需要执行查询。然而, 将这项工作推迟到执行时间是相当普遍的。 如果查询分析并传递验证, 则查询的内部格式将传递到查询重写模块以进行进一步处理。

4.2 查询重写

查询重写模块或重写程序负责简化和规范化查询, 而不更改其语义。它只能依赖于目录中的查询和元数据, 并且不能访问表中的数据。虽然我们谈到 "重写" 查询, 但大多数 rewriters 实际上是对查询的内部表示形式进行操作, 而不是在原始 SQL 语句文本上运行。查询重写模块通常以其输入时接受的相同内部格式输出查询的内部表示形式。
许多商业系统中的重写程序是一个逻辑组件, 其实际实现是在查询的后期阶段或查询优化的早期阶段。例如, 在 DB2 中, 重写程序是一个独立的组件, 而在 SQL server 中, 查询重写是作为查询优化器的早期阶段完成的。Nonethe, 即使在所有系统中不存在显式体系结构边界, 也可以单独考虑重写程序。
重写程序的主要职责是:
·查看扩展: 处理视图是重写程序的主要传统角色。对于出现在 from 子句中的每个视图引用, 重写程序从目录管理器中检索视图定义。然后, 它将查询重写为 (1) 用视图引用的表和谓词替换该视图, (2) 用 umn 对视图中的表的引用替换对该视图的任何引用。此过程以递归方式应用, 直到查询以独占方式表达到表上, 并且不包含任何视图。这种视图扩展技术, 首先建议在安格尔 [85] 中基于 set 的奎尔萨拉斯语言, 需要在 SQL 中注意正确处理 dupli 消除、嵌套查询、null 和其他棘手的细节 [68]。
·常数算术计算: 查询重写可以简化常量算术表达式: 例如, r. x 10 + 2 + r. y 被改写为 r x 12 + 不对

谓词的逻辑重写: 根据 where 子句中的谓词和常量应用逻辑重写。

简单的布尔逻辑通常用于改进表达式和基于索引的访问方法的功能之间的匹配。一个谓词, 如不 Emp. 薪资 1000000, 例如, 可能被改写为 Emp. 薪水 = 1000000。通过简单的满足测试, 这些逻辑重写甚至可以短路查询执行。意境的 Emp. 例如, 工资 < 75000 AND [Emp.salary](https://ssl.microsofttranslator.com/bv.aspx?from=&to=zh-CHS&a=Emp.salary) > 1000000 可以用 FALSE 替换。这可能允许系统在不访问数据库的情况下返回空查询结果。极小查询看似不可信, 但回想起来, 谓词可能是 "隐藏" 在视图 def initions 中, 而对外部查询的作者未知。例如, 上面的查询可能是由于在一个名为 "执行官" 的视图中对工资过低的员工进行查询而导致的。Unsat isfiable 谓词还构成 Microsoft SQL server 并行安装中的 "分区 elimina" 的基础: 当一个关系水平范围通过磁盘卷-umes 通过范围谓词进行分区时, 如果该查询的范围-分区谓词与查询谓词一起极小。 另外一个重要的逻辑重写使用谓词的 transi 活性来诱导新谓词 r. x 10 和 r. y, 例如, 建议添加额外的 pred icate "和 S. y 10."添加这些可传递谓词可提高优化程序选择在执行早期筛选数据的计划, 特别是通过使用基于索引的访问方法。 ·语义优化: 在许多情况下, 架构上的完整性约束存储在目录中, 可用于帮助重写某些查询。这种优化的一个重要例子是冗余连接消除。当外键约束将一个表的列 (例如 Emp deptno) 绑定到另一个表 (部门) 时, 就会出现这种情况。考虑到这样一个外键约束, 众所周知, 每个 emp 都有一个部门, 而且如果没有相应的部门元组 (父级), emp 元组就不可能存在。

请考虑联接两个表的查询, 但不
使用部门专栏:
    选择 emp. 名称, emp. 工资
      从 Emp, 部门
      在那里 Emp deptno = 部门 dno
可以重写此类查询以删除部门表 (假设 Emp. deptno 被限制为非 null), 因此该联接。同样, 这种看似不可信的 scenar-ios 通常是通过视图自然产生的。例如, 用户可以在联接这两个表的视图 EMPDEPT 上提交有关雇员属性的查询。数据库应用 (如 Siebel) 使用非常宽的表, 如果基础数据库不支持足够宽的表, 它们将使用多个表, 并在这些表上查看视图。如果没有冗余连接消除, 这种基于视图的宽表实现将执行得非常差。
当表的约束与查询谓词不兼容时, 语义优化还可以完全规避查询 execu。
·子查询拼合和其他启发式重写: 查询 mizers 是当前代商业 DBMSs 中最复杂的组件之一。为了保持这一复杂性的界限, 大多数优化在单独的 SELECT 查询块中进行操作, 而不是跨块迈兹。因此, 许多系统将查询重写为更适合优化程序的表单, 而不是进一步复杂化查询优化。此转换有时称为查询规范化。正常 izations 的一个示例类是将语义上等效的查询重写为规范形式, 以确保对语义对等查询进行优化以生成相同的查询计划。另一个重要的启发式方法是在可能时拼合嵌套查询, 以最大程度地暴露查询优化器的单块优化的机会。由于重复语义、子查询、null 和 correla [68、80] 等问题, 在 SQL 中的某些情况下, 这是非常棘手的。在早期, 子查询拼合是纯粹的启发式重写, 但有些产品现在基于成本分析的重写决策。其他重写在查询块中也是可能的。例如, 谓词 transi 活性可以允许在子查询 [52] 中复制谓词。拼合相关子查询对于在并行 archi tectures 中实现良好的性能尤为重要: 相关子查询导致在查询块之间进行 "嵌套循环" 样式比较, 这将序列化子查询的 exe 起诉应对, 尽管并行资源的可用性。