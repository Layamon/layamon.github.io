---
layout: post
title: Linux IO杂谈
date: 2019-06-06 15:52
header-img: "img/head.jpg"
categories: jekyll update
tags:
  - Linux
typora-root-url: ../../yummyliu.github.io
---

* TOC
{:toc}
## 概述

```c++
#include <fstream>
#include <cstring>
#include <iostream>
using namespace std;

struct Person
{
	char name[50];
	int age;
	char phone[24];
	double high;
};

int main () {
	Person mem;
	ifstream infile;
	infile.open("log.dat", ios::binary|ios::in);
	infile.read((char*)&mem, sizeof(Person));
	infile.close();
  
  mem.age++;
	std::cout << mem.age  << ' ';
	std::cout << mem.name << ' ';
	std::cout << mem.phone<< ' ';
	std::cout << mem.high<< std::endl;

	ofstream outfile;
	outfile.open("log.dat", ios::binary|ios::out);
	outfile.write((char*)&mem, sizeof(mem));
	outfile.close();


	return 0;
}
```



![img](/image/linuxio.png)

## Linux AIO 与 directio

> [http://nginx.org/en/docs/http/ngx_http_core_module.html#aio](http://nginx.org/en/docs/http/ngx_http_core_module.html#aio)
>
> When both AIO and [sendfile](http://nginx.org/en/docs/http/ngx_http_core_module.html#sendfile) are enabled on Linux, AIO is used for files that are larger than or equal to the size specified in the [directio](http://nginx.org/en/docs/http/ngx_http_core_module.html#directio) directive, while [sendfile](http://nginx.org/en/docs/http/ngx_http_core_module.html#sendfile) is used for files of smaller sizes or when [directio](http://nginx.org/en/docs/http/ngx_http_core_module.html#directio) is disabled.

## zero-copy

### sendfile()

（Java NIO的transferTo）：不需要内核态和用户态之间的数据拷贝，但是DMA需要在内核中需要维护一个连续的buffer用来传输数据。

![img](/image/sendfile.png)

如果硬件上支持*scatter-n-gather*，那么可以省去这个buffer。

![img](/image/scater.png)

## memory-map

### mmap()/munmap()

![img](/image/mmap.png)

（Java NIO的MappedByteBuffer）上面的zero-copy中，用户态进程只能等待IO完成。如果期间希望操作数据，可以使用mmap。mmap将外存的文件块映射到内存中，虽然又带来了4次上下文切换，但是可以利用OS的页面管理（虚拟空间映射，页面缓存与自动刷出，页面对齐等）。同样会带来占用进程页表和TLB缓存的代价。































































考虑到文件系统如果支持sparsefile，那么文件的物理大小和逻辑大小是不同的。ll 显示的是逻辑大小，du显示的是按block（默认是1024byte）为单位的物理大小。因此有如下情况，du显示是4（就是4*1024，4k），ll显示的是1025（就是逻辑上的大小）

```bash
# dd if=/dev/zero of=test bs=1 count=1025
1025+0 records in
1025+0 records out
1025 bytes (1.0 kB) copied, 0.00209302 s, 490 kB/s
[12:29:04] nestdb-dev /data/mydata/var
# ll
-rw-r--r-- 1 root root       1025 Aug 13 12:29 test
[12:29:16] nestdb-dev /data/mydata/var
# du test
4       test
```

通过fallocate，可以在文件中打洞，如下，打洞后，du还是按block为单位显示实际占用大小，ls还是逻辑大小

```bash
# dd if=/dev/zero of=test bs=1 count=4097
4097+0 records in
4097+0 records out
4097 bytes (4.1 kB) copied, 0.00877725 s, 467 kB/s

# ls -l
-rw-r--r-- 1 root root       4097 Aug 13 12:31 test

# du test
8       test

# fallocate -n -p -o 4095 -l 5 test

# du test
4       test

# ls -l
-rw-r--r-- 1 root root       4097 Aug 13 12:31 test
```

