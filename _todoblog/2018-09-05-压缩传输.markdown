---
layout: post
title: 运维操作——传输数据
date: 2018-09-05 18:46
header-img: "img/head.jpg"
categories: jekyll update
tags:
typora-root-url: ../../yummyliu.github.io
---

> * TOC
{:toc}



![](/image/dis.png)

### 分布式？

单台服务器不足以解决现在的网络请求的，需要扩展现在的服务；对于每个服务的数据，往往需要将数据按照一定规则进行数据分片分节点存储。在分布式环境中，需要对cap进行取舍；

- Partition tolerance 容灾：数据不丢，结点的failover，数据副本是分布式系统解决数据丢失异常的**唯一手段**。
- Consistence 数据一致性：事务处理
- Availability 性能： 吞吐量，响应时间

我觉得最重要的是P，在保证P的前提下，系统在C和A之前取舍，这带来了多种分布式一致性方案。

> cap:  
>
> 数据分布存储中，为了防止某一分片的损坏或不可达，将同一份数据在多节点上存储；冗余越多，Partition tolerance越高，但多节点上的一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。

### 一致性模型 

- 弱一致性：当你写一个新值后，读操作在数据副本上可能读出来，也可能读不出来

- 最终一致性：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。

  如，DNS/电子邮件/Amazon S3/Google搜索引擎。

- 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。

  比如，文件系统/RDBMS/Azure Table

> 从三种一致性模型上来说，前两种一般是异步冗余的，第三种是同步冗余的

#### Master-Slave

在这种架构中，Slave是Master的备份：

- 写请求都由Master负责，在slave上读；
- 写请求写到Master上后，由Master同步到Slave上

从Master同步到Slave，可以使用Master来push，可以使用Slave来pull；

#### Master-Master

系统中存在多个Master，每个Master都提供read-write服务，数据间的同步通过Master间的异步完成，所以是最终一致性。但多个Master对同一个数据进行修改的时候，这个模型的噩梦就出现了——对数据间的冲突的合并。

#### Two(Three) Phase Commit

两阶段提交，在分布式系统中每个节点无法得知其他节点成功与否，当一个事物跨越多个节点的时候，为了保持事物的ACID特性，需要引入一个作为*协调者*的组件来统一掌握所有节点（*参与者*）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交：

##### 第一阶段：vote

1. 协调者问所有参与者节点是否可以提交操作。
2. 各个参与者开始事务执行的准备工作；如为资源上锁，预留资源，写undo/redo log...
3. 参与者响应协调者，准备工作成功，回应『可以提交』否则『拒绝提交』

##### 第二阶段：decision

- 如果所有参与者都回应可以提交，那么协调者向所有的参与者发送『正式提交』的命令，参与者完成正式提交，并释放所有资源，然后回应『完成』，协调者收集各个几点的『完成』回应后，结束这个全局事务。
- 如果有一个参与者回应『拒绝提交』，那么，协调者向所有的参与者发送『回滚操作』。并释放所有资源，然后回应『回滚完成』，协调者收集各个节点的回滚回应后，取消这个全局事务。

> 2PC是一个强一致性的算法。在一些系统设计中，会串联一些调用，每一步调用都要分配一些资源或改写一些数据，使用**try->confirm**的方式来确保整个流程能够成功完成。

##### 2PC问题

- 其中一个是同步阻塞操作，必然会影响性能
- 另一个问题在timeout上：在系统中如果是 协调者发的信息参与者回应超时，协调者可以选着重发，或者把其视为问题节点，剔除集群；但若是协调者崩了，参与者收不到协调者的指令，所有参与者将处在不知所措的状态；比如最大的问题就是在**第一阶段完成后，参与者在第二阶段没有收到决策，那么数据节点会进入『不知所措』的状态，这个状态会block住整个事物**。

所以，协调者的可用性是个关键，因此，我们引入3pc，把2pc的第一阶段拆成两个阶段，先询问，再锁资源，最后提交。**在询问的时候不锁资源，除非所有人同意了才开始锁资源**

这样在precommit后，如果发生了Failuer/Timeou的问题，比起2pc，3pc可以继续直接把状态变成Commit

> timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所适从，你也不知道对方是做了还是没有做，于是状态机就因为timeout成了摆设

#### Paxos算法

> 该算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生一上任何异常都不会破坏决议的一致性。
> 一个典型的场景，在一个分布式数据库系统中，如果各个节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态，为保证灭个节点都执行相同的操作序列，需要在每条指令上执行一个『一致性算法』以保证每个节点看到的指令一致。

Paxos的目的是让整个集群的节点对某个值的变更达成一致。任何一个点都可以提出修改这个数据的提案，是否通过取决于这个集群中是否有超过半数的节点的同意（所以要求集群的阶段是单数）。