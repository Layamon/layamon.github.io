---
layout: post
title: 认识MyRocks
date: 2020-02-27 10:51
categories:
  - MySQL
typora-root-url: ../../yummyliu.github.io
---
* TOC
{:toc}

在[from btree to lsm-tree](http://liuyangming.tech/12-2019/leveldb.html)中，我们了解到写B+-tree时，写一条记录就意味着写一个页；不考虑bufferpool的合并写和dwbuffer的写放大，在InnoDB中，如果业务负载随机写N条记录，最坏的情况下，就意味着要写N个页；这带来很大的**写放大**。

另外，每个页中都有一些碎片空间，这些无用空间会浪费IO带宽；针对这个，InnoDB中设计了Compressed Page，而Compressed Page同样是要对齐存储（0~4kb对齐到4kb，4~8kb对齐到8kb，8~16kb对齐到16kb），只要对齐就会存在空闲空间。这带来了**空间放大**。

B+-tree的设计是针对HDD，现在SSD也在大面积使用，因此上次数据库存储引擎也出现了变革。

> 搞明白几个概念：**电气接口**、**存储协议**、**存储介质**。当我们有一个主机，现在要接入外接设备，设备要插到主板上，需要该设备能够满足主板上的**电气接口（总线规范）**；插上去后，操作系统上安装相应设备的驱动，驱动中有设备的**存储协议**；之后的IO就封装成相应存储协议的命令，写到外存的**存储介质**上去。电气接口主要有SATA、SAS、PCIe；存储协议有AHCI、SCSI、NVMe；存储介质有NAND、3D-Xpoint。
>
> ![image-20200227141415425](/image/2020-0227-nand.png)

LSM-tree目前获得了很多目光，MySQL中也可以集成LSM-tree架构的存储引擎——RocksDB，叫MyRocks。本文是作者对MyRocks学习的总结，希望对想了解这个产品的同学有所帮助。

# RocksDB Overview

我简单画了下rocksdb的大致架构图，如下：

![image-20200227180548341](/image/2020-0227-rocksdb-overview.png)

其中省去了进行读优化的组件，比如Index、BloomFilter和Block Cache。另外，在RocksDB3.0中，引入了Column Family（下称CF）的概念，通过CF将(k,v)进行了逻辑上的分区，这样不同分区可以分别写自己的MemTable和SSTTable，但是共享同一个WAL；但是RocksDB保证**跨CF的的原子写**和**一致性读**快照，以及可以分别对不同CF进行挂载、删除与配置。

相比于B+-tree在写放大和空间放大上的不足，LSM-tree能够通过合并随机写减少写放大，以及通过高效的压缩减少空间放大。

+ 合并随机写，事务提交时，除了日志必须要落盘外，数据只要写在Active MemTable中即可。
+ 高效压缩:
  + Prefix Key Encoding：RocksDB中，通过多列索引支持covering secondary index，在索引中将前缀进行修整，达到压缩空间的目的。
  + Zero-Filling metadata：在InnoDB的record上，有事务ID（6 bytes）和回滚段指针（7 bytes），但是不可压缩；RocksDB中每个KV上有一个sequence id（7 bytes）和操作符标识（1 bytes），是可以压缩的，并且如果sequence id在MVCC中用不到，那么可以置零。



|            | InnoDB                               | RocksDB                                  |
| ---------- | ------------------------------------ | ---------------------------------------- |
| 点查       | 从上到下按照某个分支进行定位。       | 逐层查找，可以基于bloom filter进行过滤。 |
| range scan | 直接按照leafnode的next指针进行遍历。 | 需要合并不同层的数据。                   |
| delete     | 标记删除                             | 标记删除，tombstone；singledelete优化。  |

# MyRocks

Major feature sets in MyRocks

+ Similar feature set sas InnoDB
+ Transaction
  + Atomicity
  + MVCC / Non locking consistent reads
  + Read Committed, Repeatable Read (PostgreSQL-style)
  + Crash safe slave and master
  + OnlineBackup

+ Logical backup by mysqldump

- Binary backup by myrocks_hotbackup

相比于MySQL（InnoDB），MyRocks有

- Supports PRIMARY KEY and SECONDARY KEY
- Fulltext, Foreign, Spatial indexes are not supported
- Tablespace is not supported
- Online DDL has not been supported yet

## Primary & Secondary Index

一二级索引对比

|                 | Key                                                          | Value                        | Metadata           |
| --------------- | ------------------------------------------------------------ | ---------------------------- | ------------------ |
| Primary Index   | Internal Index ID（4bytes）+ primary key columns             | remaining columns + checksum | Sequence ID + flag |
| Secondary Index | Internal Index ID（4bytes）+ secondary key columns + primary key (去重) | checksum                     | Sequence ID + flag |

因为使用了Prefix Key Encoding，Internal Index ID不会存在空间代价。和InnoDB的Primary Index相同，RocksDB的Primary Index同样是聚集索引；因此，基于主键的查询可以一步到位（例如，where a=1相关记录都在一起，直接定位）；基于二级索引的查询，同样可以通过Covering Index避免对主键的二次查询。同样地，对于没有主键的表，RocksDB会创建一个隐藏主键，称之为Hidden Primary Key；

在创建表和索引时，可在INDEX COMMENT中指定CF，CF与index是1：N的关系，如果没有指定CF，将放在default-CF中（注意，不要创建太多的CF，20个足以）。

```sql
CREATE TABLE `linktable` (
`id1` bigint unsigned,
`id1_type` int unsigned,
`id2` bigint unsigned,
`id2_type` int unsigned,
`link_type` bigint unsigned,
`visibility` tinyint NOT NULL,
`data` varchar NOT NULL,
`time` bigint unsigned NOT NULL,
`version` int unsigned NOT NULL,
PRIMARY KEY (link_type, `id1`,`id2`) COMMENT 'cf_link_pk',
KEY `id1_type` (`id1`,`link_type`,`visibility`,`time`,`version`,`data`) COMMENT 'rev:cf_link_id1_type'
) ENGINE=RocksDB DEFAULT COLLATE=latin1_bin;
```

RocksDB前向扫描块，ORDER BY DESC慢（原因？），rev:是表示创建一个Reversed Column Family。

## Read&Write

InnoDB在数据变更时，如果page不在bufferpool中，会发生 reads on index writes。RocksDB直接put到Active MemTable中即可。

Delete会在数据上架一个tombstone，读取的时候会忽略该key所有put语句；如果某个key的put操作只出现了一次，那么执行delete时，做singledelete；即真正的删除数据。

### 查询估计

通过GetApproximateSizes得到某区间的大概元组数，在MySQL optimizer中用来找最佳查询计划。

## Concurrency

### 锁

MyRocks的锁粒度是row lock，其锁信息都在内存中；暂不支持共享锁，因此对于`select * from t where id = 3 for shared`也是降级为排他锁。并且在MyRocks中，不支持自动死锁检测；

相比于InnoDB的Gap lock，MyRocks的GapLock不会锁住没有找到的record；只有Gap的范围是整个Primary Key，才会使用和InnoDB相同。这也要求MyRocks的master要基于Row based进行复制；如下例，在master上，先执行delete语句，由于MyRocks的GapLock只会将ID=10的record锁住，因此update语句可以在delete之前提交，那么在实际的binlog中，如果采用statement的方式复制，slave端就先执行update后delete，这样主从数据就不一致了。

![image-20200303114709689](/image/20200227-gaplock.png)

### 事务

MyRocks事务不支持SAVEPOINT，事务隔离和PostgreSQL类似，是基于快照的隔离，但是不支持RU和Serializable的隔离级别；因此对于locking read，PostgreSQL和MyRocks是读快照数据，InnoDB读的是当前的数据，并且也会锁住不存在的key。有一点区别是，RR级别下PostgreSQL是在事务开始时获取的快照，MyRocks是在第一条语句获取快照。

在InnoDB中，后面的事务更新了前面事务的数据，在RC、RR级别下都可以overwrite；而在MyRocks中，只有在RC级别上才可以，这和PostgreSQL相同；

因此，如果将InnoDB上的业务迁移到MyRocks上，能够减少一些锁的竞争，但是需要注意GapLock的问题；有些依赖gaplock的查询，在MyRocks中会返回Deadlock的错误，有些并不能有效完成，为排查这个问题，MyRocks提供了两个参数：`gap_lock_raise_error`和`gap_lock_write_log`；

> 一些查询语义上需要将表中不存在的key也锁上，这就依赖gaplock，比如:
>
> 1. empty check
> 2. prefix uniqueness
> 3. blocking queue
> 4. pt-table-checksum

## Replication

上面将GapLock提到了，MyRocks的主从复制要求使用Row模式，为解决一些潜在问题Facebook添加了一些参数：

```conf
▪ binlog_format=ROW
▪ binlog_rows_query_log_events=ON
▪ binlog_row_image=FULL
▪ slave_type_conversions=ALL_NON_LOSSY
▪ log_only_query_comments=OFF (FB extension)
▪ slave_exec_mode=SEMI_STRICT (FB extension)
▪ log_column_names=ON (FB extension)
▪ Changes binlog format
▪ slave_run_triggers_for_rbr=YES (MariaDB extension, FB backported)
▪ sql_log_bin_triggers=OFF (MariaDB extension, FB backported)
```

### Read Free Replication

之前从端进行更新删除的时候，需要从磁盘读取旧数据，由于MyRocks采用的是LSM-tree的结构，从TokuDB获得的启发，将利用Binlog的信息，从而**避免从磁盘进行随机读取**，如下图对比；这要求主端的参数`binlog_row_image=FULL`并且从端不允许变更。另外还有一个Skip Unique Checks特性，也是类似的道理。

![image-20200303142957787](/image/20200227-readfreerepl.png)

### Crash Safety

slave通过配置`relay_log_recovery`实现“Crash Safe Slave”；master failover相对复杂点，可能如果orig master的gtid大于new master的gtid，需要trim binlog，即将prepare状态的事务进行回滚（一般recovery是前滚）。

### consistent backup

mysqldump--single-transaction

InnoDB是通过roll-ptr链遍历，知道找回目标行；RocksDB是通过SeqID定义某个快照，如图，假设我们需要SeqID=5的快照，在读取快照数据过程中，在5到当前新的2000之间的SeqID，可能在FLush和Compaction过程中被合并了，那么就不需要遍历过多的版本。

![image-20200303154316446](/image/20200227-snapshot.png)

### Online Binary Backup

执行命令，SET GLOBAL rocksdb_create_checkpoint=/path/to/backup进行在线备份，执行下面两个步骤：

1. 对SSTTable创建硬链接文件（原SSTfile删除后，由于存在hardlink，那么文件还可以通过hardlink读取）
2. 然后将硬链接文件和WAL文件拷贝到别处，由于Hard Link是Immutable，因此源实例不需要停机

通过myrocks_hotbackup可以做一个类似PostgreSQL的热备，其中做了以下几件事：

1. 创建一个checkpoint，开始备份SSTfile；文件备份完成后，就将该checkpoint删除；如果到一定时间没有完成，那么重新创建一个checkpoint，不断循环直到SSTfile全部备份完成。
2. 备份剩下的文件：WAL，frm，metadata等
3. 将文件放回相应的目录中。

## Compression

compression发生在flush和Compact的过程中。decompression发生在读取的时候，在内存cache中是解压后的block；decompression相比于compression更加频繁，这要求decompression应该更高效。





**Reference** 

[各种数据库的隔离级别对比](https://github.com/ept/hermitage)

[RBR与SBR](http://www.ovaistariq.net/528/statement-based-vs-row-based-replication/)

[Read Free Replication](https://github.com/facebook/mysql-5.6/wiki/Read-Free-Replication)