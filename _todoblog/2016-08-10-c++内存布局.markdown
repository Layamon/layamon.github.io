---
layout: post
title: C++内存布局
date: 2016-08-10 15:58
header-img: "img/head.jpg"
categories: jekyll update
tags:
    - C++
---

# C++内存布局

理解每一门语言其运行时的状态的关键一步就是了解该语言运行时的内存布局。比如学习Java就要了解JVM运行时结构；这篇文章简单讲述C++运行时的内存布局，便于初学者对C++有一个概况的了解。

从如下一个简单的代码开始分析，来了解C++的结构。

```c
#include <stdio.h> 
int main(void) 
{ 
	return 0; 
}
```

通过`size`命令，我们知道文件的布局如下所示，分为三部分：text/data/bss。当代码运行起来，这就是全局区域，另外加上栈和堆就是一个应用进程的整体布局。

```bash
» size a.out
   text    data     bss     dec     hex filename
   1127     540       4    1671     687 a.out
```

## text

text就是代码段。首先我们需要了解代码是如何编译生成的？如[下图](https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html)所示，从源码到机器指令代码中间有4个步骤：

1. 预处理：宏展开，引用头文件
2. 编译：转成汇编代码
3. 汇编：将汇编代码转成机器指令
4. 链接：将多个目标文件和库文件进行链接，生成一整个可执行文件。

![img](/Users/liuyangming/yummyliu.github.io/image/GCC_CompilationProcess.png)

其中在第4步中，如果是静态库那么每个可执行文件中都会有一个静态库的代码拷贝。这样最终的可执行文件就会比较臃肿；因此，提出了另一个动态（共享）库的链接方式，基于动态库的链接并不会将库代码整合到可执行文件中，而是在可执行文件执行的时候，如果调用了动态库，那么才进行加载。这样可执行文件比较小，并且可以动态更新模块，更加灵活；但是由于具体调用的时候需要对函数入口进行相对寻址，这样效率上比静态库会慢一些；而且动态库是在系统中单独存放，存在被人误删等异常操作，从而影响可执行文件的稳定。

### 动态连接库的系统共享

比如libc.so就是一个常用的动态库，该动态库被系统大多数进程共享使用。在链接过程中，可执行文件中会创建一个**符号映射表**。在app执行的时候，OS将控制权先给`ld.so`，而不是先给app。`ld.so`会找到并引入的lib；然后将控制权转给app。

> ld搜索lib路径先后顺序:
>
> +  DT_RPATH
> +  LD_LIBRARY_PATH
> +  /etc/ld.so.cache
> +  DT_RUNPATH
> +  /lib(64) or /usr/lib(64)
>

对于动态库的全局代码段，每个进程维护通过相对寻址来执行。而对于动态库中的非常量全局变量不是共享的，每个进程一个拷贝。

## data

**已经初始化**的全局变量和静态变量

### 动态链接库的全局变量

## bss

> block started by symbol

**没有初始化**的全局变量和静态变量，一般操作系统对其进行置零初始化。

### 类的成员函数初始化

## stack

### 变量作用域

## heap

> Free store

### 变量生存时间

# C++内存操作

## 内存申请

### new vs malloc

| NEW                              | MALLOC                      |
| -------------------------------- | --------------------------- |
| calls constructor                | doesnot calls constructors  |
| It is an operator                | It is a function            |
| Returns exact data type          | Returns void *              |
| on failure, Throws               | On failure, returns NULL    |
| Memory allocated from free store | Memory allocated from heap  |
| can be overridden                | cannot be overridden        |
| size is calculated by compiler   | size is calculated manually |

## 内存释放

delete和 free()一定要和new/malloc()对应使用。

## 内存泄露

``` c
typedef char CStr[100];
...
void foo()
{
  ...
  char* a_string = new CStr;
  ...
  delete a_string;
  return;
}
```

如上,`delete a_string`的时候,就会发生内存泄露

+ 野指针，悬垂指针：Wild pointer/Dangling pointer；指针没有初始化，或者指针free后，没有置NULL

+ 内存耗尽：memory exhausted；分配内存后要判断，内存是否分配成功，失败就结束该程序

### RAII

**"RAII: Resource Acquisition Is Initialization"**
意思就是任何资源的获取，不管是不是在初始化阶段，都是被一个对象获得，
而相应的释放资源就在该对象的析构函数中,资源不限于内存资源，
包括file handles, mutexes, database connections, transactions等。

c++ 本身不提供垃圾回收的机制（尽管有一些相应的第三方库），
比起Java等类似语言的finally construct的方式，要优。

同样和C语言中的内存管理相比，要优的多。源于c++的封装，比如：

``` c
#include <stdio.h>  // for puts, getchar, stdin
#include <stdlib.h> // for malloc and free

char *getstr(int minlen, int inc) // minlen - Minimum length, inc - Increment of length
{
  int index;
  int ch;
  char *str = malloc(minlen);

  for (index = 0; (ch = getchar()) != EOF && ch != '\n'; index++)
  {
    if (index >= minlen - 1)
    {
      char *str1;
      minlen += inc;
      str1 = realloc(str, minlen);
      str = str1;
    }
    str[index] = (char)ch;
  }
  str[index] = 0;  // mark end of string
  return str;
}

int main()
{
  char* name;
  puts("Please enter your full name: ");
  name = getstr(10, 10);  // 10, 10 are arbitrary
  printf("Hello %s\n", name);
  free(name);
  return 0;
}
```

``` cpp
#include <string>   // for std::string and std::getline
#include <iostream> // for std::cin and std::cout

int main() {
  std::string name;
  std::cout << "Please enter your full name: ";
  std::getline(std::cin, name);
  std::cout << "Hello " << name << '\n';
  return 0;
}
```

### 智能指针

> 这是很有效的方法，来管理动态分配对象的生命周期。

智能指针从某种意义上来说，不是一个真的指针，但是重载了 `->` `*` `->*`指针运算符，
这使得其表现的像个内建的指针

`auto_ptr, shared_ptr, weak_ptr, unique_ptr`
后三个是c++11支持的，第一个已经被弃用了,相应的在boost中也有只能指针，不过现在c++11已经支持了就不用了，
boost:scoped_ptr 类似于 std:unique_ptr

##### unique_ptr

不可复制

##### shared_ptr

可以复制，维护一个引用计数，当最后一个引用该对象的引用退出，那么才销毁

但是可能带来的问题是 : 

1. dangling reference

``` cpp
// Create the smart pointer on the heap
MyObjectPtr* pp = new MyObjectPtr(new MyObject())
// Hmm, we forgot to destroy the smart pointer,
// because of that, the object is never destroyed!
```

2. circular reference

``` cpp
struct Owner {
   boost::shared_ptr<Owner> other;
};

boost::shared_ptr<Owner> p1 (new Owner());
boost::shared_ptr<Owner> p2 (new Owner());
p1->other = p2; // p1 references p2
p2->other = p1; // p2 references p1
```

##### weak_pointer

配合shared_ptr使用，避免循环引用的问题

shared_ptr：
每一个shared_ptr对象内部，拥有两个指针ref_ptr与res_ptr，一个指向引用计数对象，一个指向实际的资源。
在shared_ptr的拷贝构造等需要创造出其他拥有相同资源的shared_ptr对象时，会首先增加引用计数，然后将ref_ptr与res_ptr复值给新对象。
发生析构时，减小引用计数，查看是否为0，如果是，则释放res_ptr与ref_ptr。
weak_ptr简单介绍：
weak_ptr的引入，我认为是smart_ptr概念的一个补全。一个raw指针，其实有两个含义，一是管理资源的句柄（拥有对象），一是指向一个资源的指针（不拥有对象）。举个例子，一般我们创建一个对象，在使用完之后销毁，那这个指针是拥有那个对象的，指针的作用域就是这个对象的生命周期，这个指针就是第一类指针。我们在使用observer模式时，被监测对象经常会持有所有observer的指针，以便在有更新时去通知他们，但是他并不拥有那些对象，这类指针就是第二类指针。在引入smart_ptr之前，资源的创建与释放都是调用者来做决定，所以一个指针是哪一类，完全由程序员自己控制。但是smart_ptr引入之后，这个概念就凸显出来。试想，在observer例子中，我们不会容许一个对象因为他是某一个对象的观察者就无法被释放。weak_ptr就是第二类指针的实现，他不拥有资源，当需要时，他可以通过lock获得资源的短期使用权。
