---
layout: post
title: 一个笔试题
date: 2016-04-07 14:57
categories: jekyll update
---

描述
You work as an intern at a robotics startup. Today is your company's demo day. During the demo your company's robot will be put in a maze and without any information about the maze, it should be able to find a way out.

The maze consists of N * M grids. Each grid is either empty(represented by '.') or blocked by an obstacle(represented by 'b'). The robot will be release at the top left corner and the exit is at the bottom right corner.

Unfortunately some sensors on the robot go crazy just before the demo starts. As a result, the robot can only repeats two operations alternatively: keep moving to the right until it can't and keep moving to the bottom until it can't. At the beginning, the robot keeps moving to the right.

rrrrbb..            
...r....     ====> The robot route with broken sensors is marked by 'r'. 
...rrb..
...bb...
While the FTEs(full-time employees) are busy working on the sensors, you try to save the demo day by rearranging the maze in such a way that even with the broken sensors the robot can reach the exit successfully. You can change a grid from empty to blocked and vice versa. So as not to arouse suspision, you want to change as few grids as possible. What is the mininum number?

输入
Line 1: N, M.

Line 2-N+1: the N * M maze.



For 20% of the data, N * M <= 16.

For 50% of the data, 1 <= N, M <= 8.

For 100% of the data, 1<= N, M <= 100.

输出
The minimum number of grids to be changed.

样例输入
4 8
....bb..
........
.....b..
...bb...
样例输出
1

> 题目如上，这个题花了时间很长，记录一下思路历程
> 考虑这个题的时候，首先从理解题目开始就出现的偏差，代码一定不要着急开始写，多想想，就能在没写代码的时候，尽力避开一些陷阱
> 做这个题的时候，题意理解错了，写了两个不符合题意的答案

### 思路一：广搜

看到这是一个迷宫的题，首先就想到用广搜解，故按照机器人走路时遇到墙就改变状态来实现代码广搜
仔细看看题， 不仅仅是把'b'变成'.' 而且要考虑把
'.'变'b'，而我的广搜只考虑了把'b'变成'.'

### 思路二：动态规划

考虑机器人并非只在撞到墙才考虑转弯，dp[i][j][2] : 在(i,j)的时候，方向向下和向右的最小破墙数,
考虑机器人在走到任何(i,j)时，都可以转弯

### 思路三： 动态规划

1、机器人是撞到墙才考虑转弯 （思路二的错）
2、**You can change a grid from empty to blocked and vice versa** 我们可做不只是把墙变没，还可以变出墙 （思路一的错）

遍历到（i,j）的时候，可考虑更新（i+1,j）(i,j+1)
如果要转弯，要看另一个方向的前一个位置，如果是'.'就需要变成'b';
如果不转弯，就要看该方向的前一个位置是不是'b',是的话，要变成'.';

关于初始状态的设置，刚开始设置的不对，所以一直wa
原来考虑开始的时候状态只和左上角元素是否是'b'有关，设置成：
	dp[0][0][0] = (maze[0][0]=='b');
	dp[0][0][1] = (maze[0][0]=='b');
但这个问题中的状态不仅仅是二维的（i,j）,而应该是三维的(i,j,k),题中说了开始放在左上角向右
初始状态，应只有一个，另一个方向为何要考虑转弯的花销：
	(0,0)方向向右，故dp[0][0][0] = ((maze[0][0]=='b'))

{% highlight c++ %}

#include <iostream>
#include <vector>
#include <queue>
#include <string>
// #include <string.h>
using namespace std;

class State
 {
 public:
 	State(int ti,int tj,int tdes,int tans){
 		i = ti;
 		j = tj;
 		des = tdes;
 		ans = tans;
 	}
	 int i;
	 int j;
	 bool des;
	 int ans;
 };
bool visit[101][101][2];
bool isvisit(int i, int j, int des){
	if(des){
		return visit[i][j][0];
	}else{
		return visit[i][j][1];
	}
}
void printvisit(int i, int j, int des){
	if(des){
		visit[i][j][0] = true;
	}else{
		visit[i][j][1] = true;
	}	
}
int bfs(vector<vector<char>> &maze,int N, int M){
	// this is wrong answer, 
	// 广搜的时候搜集的状态，只是撞墙的时候将 'b'变成'.' 而实际上 我们可以把迷宫中的任意'.' 变成'b'

	for(int i=0;i<N;i++){
		for( int j=0;j<M;j++){
			visit[i][j][0] = false;
			visit[i][j][1] = false;
		}
	}

	queue<State> que;
	State *newstate = new State(0,0,true,0);
	que.push(*newstate);
	printvisit(0,0,true);

	int minans = N*M;
	while(!que.empty()){
		State &ts = que.front();
		que.pop();
		if(ts.des){
			//move right
			int &i =  ts.i;
			int &j = ts.j;
			int &myans = ts.ans;
			while(j+1<M && maze[i][j+1]!='b') j++;
			if(j==M-1 && i==N-1){
				if (myans < minans){
					minans = myans;
				}
			}
			else{
				//move down
				if(!isvisit(i,j,false)){
					State *nstate = new State(i,j,false,myans);
					que.push(*nstate);
					printvisit(i,j,false);
				}
				//break it
				myans ++;
				j++;
				if(j<M && !isvisit(ts.i,ts.j,ts.des)){
					que.push(ts);
					printvisit(ts.i,ts.j,ts.des);
				}
			}
		}else{
			//move down
			int &i =  ts.i;
			int &j = ts.j;
			int &myans = ts.ans;
			while(i+1<N && maze[i+1][j]!='b') i++;
			if(i==N-1 && j==M-1){
				if (myans < minans){
					minans = myans;
				}
			}
			else{
				//move right
				if(!isvisit(i,j,true)){
					State *nstate = new State(i,j,true,myans);
					que.push(*nstate);
					printvisit(i,j,true);
				}
				//break it
				myans ++;
				i++;
				if(i<N && !isvisit(ts.i,ts.j,ts.des)){
					que.push(ts);
					printvisit(ts.i,ts.j,ts.des);
				}
			}
		}
	}
	return minans;
}

int dp(vector<vector<char>> &b, int N, int M){
	int dp[N][M][2];
	// this also wrong ,robot can change way only when it hit into a block
	memset(dp,0x7f,N*M*2*(sizeof(int)));
	dp[0][0][0] = (b[0][0]=='b');
	dp[0][0][1] = (b[0][0]=='b');
	for(int i=0;i<N;i++){
		for(int j=0;j<M;j++){
			int vflag = b[i][j]=='b';
			if(j-1>=0){
				dp[i][j][0] = std::min(dp[i][j][0],dp[i][j-1][0]+vflag);
				dp[i][j][1] = std::min(dp[i][j][1],dp[i][j-1][0]+vflag);
			}
			if(i-1>=0){
				dp[i][j][0] = std::min(dp[i][j][0],dp[i-1][j][1]+vflag);
				dp[i][j][1] = std::min(dp[i][j][1],dp[i-1][j][1]+vflag);
			}
		}
	}

	return std::min(dp[N-1][M-1][0],dp[N-1][M-1][1]);
}
int dps[100][100][2]; //分配成函数局部数组变量的时候，使用的时候出现莫名的段错误

int dp2(vector<vector<char>> &b, int N, int M){
    memset(dps,0x7f,100*100*2*(sizeof(int)));

    dps[0][0][0] = 0;
    for(int i=0;i<N;i++){
        for(int j=0;j<M;j++){
            dps[i][j][0] = min(dps[i][j][0], dps[i][j][1] + (b[i + 1][j] != 'b'));
            dps[i][j][1] = min(dps[i][j][1], dps[i][j][0] + (b[i][j + 1] != 'b'));
            dps[i][j + 1][0] = min(dps[i][j + 1][0] ,dps[i][j][0] + (b[i][j + 1] != '.'));
            dps[i + 1][j][1] = min(dps[i + 1][j][1], dps[i][j][1] + (b[i + 1][j] != '.'));
        }
    }
    return std::min(dps[N-1][M-1][0],dps[N-1][M-1][1]);
}

int main(){

	int N,M;
	cin >> N >> M;

	vector<vector<char>> maze(N+1);
	for(int j=0;j<N+1;j++)
		maze[j].resize(M+1);
	for(int i=0;i<N;i++){
		string tmp ;
		cin >> tmp;
		for(int j=0;j<M;j++){
			maze[i][j] = tmp[j];
		}
		maze[i][M] = 'b';
	}
	for(int j=0;j<M;j++)
		maze[N][j] = 'b';
	int ans;
	ans = bfs(maze,N,M);

	ans = dp(maze,N,M);

	ans = dp2(maze,N,M);

	cout << ans << endl;

}

{% endhighlight c++ %}
