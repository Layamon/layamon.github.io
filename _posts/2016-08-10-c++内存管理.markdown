---
layout: post
title: 了解C++内存管理
date: 2016-08-10 15:58
header-img: "img/head.jpg"
categories: jekyll update
tags:
    - C++
---

### 内存问题

##### 内存泄露：memory leak

``` c
typedef char CStr[100];
...
void foo()
{
  ...
  char* a_string = new CStr;
  ...
  delete a_string;
  return;
}
```

如上,`delete a_string`的时候,就会发生内存泄露

##### 野指针，悬垂指针：Wild pointer/Dangling pointer

指针没有初始化，或者指针free后，没有置NULL

##### 内存耗尽：memory exhausted

分配内存后要判断，内存是否分配成功，失败就结束该程序

### RAII

**"RAII: Resource Acquisition Is Initialization"**
意思就是任何资源的获取，不管是不是在初始化阶段，都是被一个对象获得，
而相应的释放资源就在该对象的析构函数中,资源不限于内存资源，
包括file handles, mutexes, database connections, transactions等。

c++ 本身不提供垃圾回收的机制（尽管有一些相应的第三方库），
比起Java等类似语言的finally construct的方式，要优。

同样和C语言中的内存管理相比，要优的多。源于c++的封装，比如：

``` c
#include <stdio.h>  // for puts, getchar, stdin
#include <stdlib.h> // for malloc and free

char *getstr(int minlen, int inc) // minlen - Minimum length, inc - Increment of length
{
  int index;
  int ch;
  char *str = malloc(minlen);

  for (index = 0; (ch = getchar()) != EOF && ch != '\n'; index++)
  {
    if (index >= minlen - 1)
    {
      char *str1;
      minlen += inc;
      str1 = realloc(str, minlen);
      str = str1;
    }
    str[index] = (char)ch;
  }
  str[index] = 0;  // mark end of string
  return str;
}

int main()
{
  char* name;
  puts("Please enter your full name: ");
  name = getstr(10, 10);  // 10, 10 are arbitrary
  printf("Hello %s\n", name);
  free(name);
  return 0;
}
```

``` cpp
#include <string>   // for std::string and std::getline
#include <iostream> // for std::cin and std::cout

int main() {
  std::string name;
  std::cout << "Please enter your full name: ";
  std::getline(std::cin, name);
  std::cout << "Hello " << name << '\n';
  return 0;
}
```

### 智能指针

> 这是很有效的方法，来管理动态分配对象的生命周期。

智能指针从某种意义上来说，不是一个真的指针，但是重载了 `->` `*` `->*`指针运算符，
这使得其表现的像个内建的指针

`auto_ptr, shared_ptr, weak_ptr, unique_ptr`
后三个是c++11支持的，第一个已经被弃用了,相应的在boost中也有只能指针，不过现在c++11已经支持了就不用了，
boost:scoped_ptr 类似于 std:unique_ptr

##### unique_ptr

不可复制

##### shared_ptr

可以复制，维护一个引用计数，当最后一个引用该对象的引用退出，那么才销毁

但是可能带来的问题是 : 

1. dangling reference

``` cpp
// Create the smart pointer on the heap
MyObjectPtr* pp = new MyObjectPtr(new MyObject())
// Hmm, we forgot to destroy the smart pointer,
// because of that, the object is never destroyed!
```

2. circular reference

``` cpp
struct Owner {
   boost::shared_ptr<Owner> other;
};

boost::shared_ptr<Owner> p1 (new Owner());
boost::shared_ptr<Owner> p2 (new Owner());
p1->other = p2; // p1 references p2
p2->other = p1; // p2 references p1
```

##### weak_pointer

配合shared_ptr使用，避免循环引用的问题

shared_ptr：
每一个shared_ptr对象内部，拥有两个指针ref_ptr与res_ptr，一个指向引用计数对象，一个指向实际的资源。
在shared_ptr的拷贝构造等需要创造出其他拥有相同资源的shared_ptr对象时，会首先增加引用计数，然后将ref_ptr与res_ptr复值给新对象。
发生析构时，减小引用计数，查看是否为0，如果是，则释放res_ptr与ref_ptr。
weak_ptr简单介绍：
weak_ptr的引入，我认为是smart_ptr概念的一个补全。一个raw指针，其实有两个含义，一是管理资源的句柄（拥有对象），一是指向一个资源的指针（不拥有对象）。举个例子，一般我们创建一个对象，在使用完之后销毁，那这个指针是拥有那个对象的，指针的作用域就是这个对象的生命周期，这个指针就是第一类指针。我们在使用observer模式时，被监测对象经常会持有所有observer的指针，以便在有更新时去通知他们，但是他并不拥有那些对象，这类指针就是第二类指针。在引入smart_ptr之前，资源的创建与释放都是调用者来做决定，所以一个指针是哪一类，完全由程序员自己控制。但是smart_ptr引入之后，这个概念就凸显出来。试想，在observer例子中，我们不会容许一个对象因为他是某一个对象的观察者就无法被释放。weak_ptr就是第二类指针的实现，他不拥有资源，当需要时，他可以通过lock获得资源的短期使用权。
