---
layout: post
title: 临时表、子查询、CTE的性能差异
date: 2016-07-11 21:23
header-img: "img/head.jpg"
tags:
    - DB
---


### 解释
> http://blog.csdn.net/sqlserverdiscovery/article/details/11369695 

#### 临时表
+ 	存储
不管是局部临时表，还是全局临时表，都会放存放在tempdb数据库中。
+ 	作用域
临时表包括：以#开头的局部临时表，以##开头的全局临时表。
局部临时表：对当前连接有效，只在创建它的存储过度、批处理、动态语句中有效，类似于C语言中局部变量的作用域。
全局临时表：在所有连接对它都结束引用时，会被删除，对创建者来说，断开连接就是结束引用；对非创建者，不再引用就是结束引用。
但最好在用完后，就通过drop  table 语句删除，及时释放资源。
+ 	特性
与普通的表一样，能定义约束，能创建索引，最关键的是有数据分布的统计信息，这样有利于优化器做出正确的执行计划，但同时它的开销和普通的表一样，一般适合数据量较大的情况。
有一个非常方便的select ... into 的用法，这也是一个特点。
  
#### 表变量
+	存储
表变量存放在tempdb数据库中。
+	作用域
和普通的变量一样，在定义表变量的存储过程、批处理、动态语句、函数结束时，会自动清除。
+	特性
可以有主键，但不能直接创建索引，也没有任何数据的统计信息,表变量适合数据量相对较小的情况。
必须要注意的是，表变量不受事务的约束，下面的例子说明了这一点：

``` sql
declare @tb table(v int primary key,vv varchar(10))  
  
begin tran  
    insert into @tb  
    select 1,'aa'  
rollback tran  
  
  
/* 虽然上面回滚了事务,但还是会返回1条记录  */
select * from @tb  
  
  
begin tran  
    update @tb  
    set vv= 'bb'  
    where v = 1  
rollback tran  
  
  
/* 返回的数据显示,update操作成功,根本没有回滚 */ 
select * from @tb  
```
 
#### CTE 通用表表达式
 
+	存储
产生的数据一般存储在内存，不会持久化存储。
也可以持久化：

``` sql
with cte  
as  
(  
select 1 as v,'aa' as vv  
union all  
select 2,'bb'  
)  
  
/* 把cte的数据存储在tb_cte表 */
select * into tb_cte  
from cte  
  
select * from tb_cte;  
  
  
/* 运用cte，删除数据  */
with cte_delete  
as  
(  
select * from tb_cte  
)  
  
delete from cte_delete where V = 1  
  
/* 返回1条数据，另一条已删除 */
select * from tb_cte  
```

当然，在实际运行时，有些部分，比如假脱机，会把数据存储在tempdb的worktable、workfile中，另外，一些大的hash join和排序操作，也会把中间数据存储在tempdb
+	作用域
只存在于当前的语句。
+	特性
在同一个语句中，一次定义，可以多次引用。另外，可以定义递归语句，不过这个递归语句的性能，还不如写个while循环来的好。
 
### 情况

以上。。。。在实际过程中，tpcds中很多查询都使用的是CTE，由于CTE没有统计信息，pg有时候给出的执行计划是在CTE上执行Nestloop，我把CTE都改成临时表了，效率明显好多了,另外就是 set nestloop = off

### 性能
> 来自stackoverflow上的解答 @Gordon Linoff http://stackoverflow.com/questions/11169550/is-there-a-performance-difference-between-cte-sub-query-and-temporary-table

SQL is a declarative language, not a procedural language. That is, you construct a SQL statement to describe the results that you want. You are not telling the SQL engine how to do the work.

As a general rule, it is a good idea to let the SQL engine and SQL optimizer find the best query plan. There are many person-years of effort that go into developing a SQL engine, so let the engineers do what they know how to do.

Of course, there are situations where the query plan is not optimal. Then you want to use query hints, restructure the query, update statistics, use temporary tables, add indexes, and so on to get better performance.

As for your question. The performance of CTEs and subqueries should, in theory, be the same since both provide the same information to the query optimizer. One difference is that a CTE used more than once could be easily identified and calculated once. The results could then be stored and read multiple times. Unfortunately, SQL Server does not seem to take advantage of this basic optimization method (you might call this common subquery elimination).

Temporary tables are a different matter, because you are providing more guidance on how the query should be run. One major difference is that the optimizer can use statistics from the temporary table to establish its query plan. This can result in performance gains. Also, if you have a complicated CTE (subquery) that is used more than once, then storing it in a temporary table will often give a performance boost. The query is executed only once.

The answer to your question is that you need to play around to get the performance you expect, particularly for complex queries that are run on a regular basis. In an ideal world, the query optimizer would find the perfect execution path. Although it often does, you may be able to find a way to get better performance.
