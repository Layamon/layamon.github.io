---
layout: post
title: IO ,linux
date: 2016-03-23 16:11
categories: jekyll update
---


#### 读什么
    
###### 流机制
    linux 提供的构造内核设备驱动程序和网络协议包的一种通用方法
    用户进程->流首（系统调用界面）(->处理模块 使用ioctl命令可压入处理模块)->设备驱动程序

#### 怎么读

###### 综述
> 解决需要监控n个操作符的场景

1. n个进程阻塞读;
    这种情况下，使用线程比使用进程简单，终止的时候，父子进程之间需要通信告知,但是使用线程就会带来线程同步的损失
    
2. 将n个描述符，设成非阻塞的方式（fcntl）,轮询之;
   这样大部分时候是在浪费了CPU时间,多任务系统中很不可取

3. 异步io,(ioctl)
    不再自己主动去问了，当描述符准备好了，内核再通知它; 可是进程收到这个信号后，如果等的不止一个描述符，这个时候，就不知道是哪个准备好了，所以需要将这个描述符，设成非阻塞的轮询一遍

4. I/O多路转接:调用一个函数,告诉内核我们关心的描述符的列表，以及我们关心其IO的那种状态（读/写/异常）,届时函数返回告诉我们


+ select/pselect
    准备好的描述符 select(最大描述符+1,read状态组，write状态组，exception状态组，可等待时间,(pselect:信号屏蔽字))

+ poll
    pollfd{
        int fd;
        short events;//关心的事件
        short reevents;//最后发生的事件
    }
    int poll(fdarray[],nfds(fd数)，timeout)
    同样是告诉系统相关信息，只是形式不同，这个不用对三种状态，各维护一个列表

**linux中异步i/o只对，streams设备和streams管道起作用，select poll对任何操作符都起作用**

5. readv/writev
    一次函数调用中读写多个非连续的缓冲区。
    同样是实现这一个操作，我们可以调用多次read、write；或者申请一个足够大的用户缓冲区,将这些复制进去，然后调用一次write
前者多次系统调用，开销必然大；
后者多了一步复制的开销,这一步复制的开销需要和readv/writev实现必然比read write复杂的开销做权衡

6. 存储映射
    mmap,将磁盘文件和内存缓冲区对应上，读写缓冲区就是读写文件,映射区域系统虚存的页长度相关，会做padding
