---
layout: post
title: PgbouncerÊ∫êÁ†Å‚Äî‚ÄîOverview
date: 2018-05-30 18:06
header-img: "img/head.jpg"
categories: 
    - Pgbouncer
---

# Êñá‰ª∂ÁªìÊûÑ

| admin.c     | showÁ≠âÁÆ°ÁêÜÊìç‰Ωú                            |
| ----------- | ------------------------------------ |
| client.c    | ÂÆ¢Êà∑Á´ØËøûÊé•handle                          |
| dnslookup.c | Âü∫‰∫éc-areÁ≠âÂ∫ìÁöÑdnsÊü•ËØ¢                      |
| hba.c       | auth_type‰∏∫hbaÊó∂ÔºåËØ•Êñá‰ª∂Áî®Êù•Âä†ËΩΩhbaÊñá‰ª∂          |
| janitor.c   | ËøûÊé•Ê±†ÁöÑÂÆöÊúüÁª¥Êä§Êìç‰Ωú                           |
| loader.c    | Âä†ËΩΩpgbouncer.iniÂíåauth_fileÊñá‰ª∂          |
| main.c      | ÂÖ•Âè£                                   |
| objects.c   | Áª¥Êä§pgbouncerÁöÑÂÜÖÈÉ®ÂØπË±°ÔºåÂêÑÁßçlistÂíåcache‰ª•ÂèätreeÁ≠â |
| pam.c       | auth_typeÁöÑÁ±ªÂûã‰∏∫pamÊó∂Áî®ÁöÑ                  |
| pktbuf.c    | packet buffer ÁöÑÊï∞ÊçÆÂåÖÁöÑÂèëÈÄÅÂíåÊé•Êî∂             |
| pooler.c    | ËøûÊé•Ê±†socketÁõëÂê¨ÁöÑÂ§ÑÁêÜhandle                 |
| proto.c     | ÂçèËÆÆÂ§¥ÈÉ®‰ø°ÊÅØÂ§ÑÁêÜ                             |
| sbuf.c      | ÊµÅÁºìÂÜ≤Âå∫                                 |
| server.c    | db serverËøûÊé•handle                    |
| stats.c     | pgbouncerËá™Ë∫´ÁöÑÁªüËÆ°‰ø°ÊÅØÔºåshow statsÁõ∏ÂÖ≥        |
| system.c    | libc‰∏çÊèê‰æõÁöÑ Ëá™Â∑±ÂÆûÁé∞ÁöÑÁ≥ªÁªüÂáΩÊï∞                   |
| takeover.c  | ‰∏Ä‰∏™ËøõÁ®ãÊé•ÁÆ°Âè¶‰∏Ä‰∏™ËøõÁ®ã                          |
| util.c      | ‰∏Ä‰∫õÂ∑•ÂÖ∑ÂáΩÊï∞                               |
| varcache.c  | ÊúçÂä°ÈÖçÁΩÆÂèÇÊï∞ÁöÑÂÄºÔºåËøûÊé•‰∏äÁöÑÁºñÁ†ÅÔºåtimezoneÁ≠â‰ø°ÊÅØ          |

+ ÂÜÖÈÉ®ÂØπË±°

  + user_listÔºönever free
  + database_list: never free
  + pool_list: never free
  + user_tree: auth_file‰∏≠ÁöÑuser
  + pam_user_tree: pamËÆ§ËØÅÊñπÂºèÁöÑuser
  + login_client_list: pam
  + server_cache
  + client_cache
  + db_cache
  + pool_cache
  + user_cache
  + iobuf_cache
  + autodatabase_idle_list

+ Êï∞ÊçÆÁªìÊûÑ

  + statlist: Â∏¶ÁªüËÆ°‰ø°ÊÅØÁöÑÂèåÂêëÈìæË°®

  + aatree: ÁÆÄÂçïÁöÑÁ∫¢ÈªëÊ†ë

  + stabÔºö Âü∫‰∫éÈìæË°®ÔºåÂ≠òÂÇ®‰∏Ä‰∫õÈ¢ÑÂÖàÂàÜÈÖçÁöÑÂØπË±°



## SBUF

Stream Buffer:

```c
/*
 * Stream Buffer.
 *
 * Stream is divided to packets.  On each packet start
 * protocol handler is called that decides what to do.
 */
struct SBuf {
	struct event ev;	/* libevent handle */

	uint8_t wait_type;	/* track wait state */
	uint8_t pkt_action;	/* method for handling current pkt */
	uint8_t tls_state;	/* progress of tls */

	int sock;		/* fd for this socket */

	unsigned pkt_remain;	/* total packet length remaining */

	sbuf_cb_t proto_cb;	/* protocol callback */

	SBuf *dst;		/* target SBuf for current packet */

	IOBuf *io;		/* data buffer, lazily allocated */

	const SBufIO *ops;	/* normal vs. TLS */
	struct tls *tls;	/* TLS context */
	const char *tls_host;	/* target hostname */
};
```

Pgbouncer‰Ωú‰∏∫clientÂíåserverÁöÑ‰∏≠Èó¥Â±ÇÔºåÈúÄË¶Å‰∏éclientÂíåserverÂàÜÂà´Âª∫Á´ãsocketËøûÊé•ÔºõSBuf‰Ωú‰∏∫Âú®‰∏çÂêåsocket‰∏≠È´òÊïà‰º†ËæìÊï∞ÊçÆÁöÑÈÄöÈÅìÔºåÂÖ∂‰∏≠ÂÆö‰πâ‰∫Ü‰∏Ä‰∫õcallbackÔºåÊ£ÄÊµãÂ§¥ÈÉ®‰ø°ÊÅØÊù•ÂÅö‰∏Ä‰∫õÂ§ÑÁêÜÔºåÂ¶Ç‰∏ãÔºö

#### signal

```c
/*
 * event types for protocol handler
 */
typedef enum {
	SBUF_EV_READ,		/* got new packet */
	SBUF_EV_RECV_FAILED,	/* error */
	SBUF_EV_SEND_FAILED,	/* error */
	SBUF_EV_CONNECT_FAILED,	/* error */
	SBUF_EV_CONNECT_OK,	/* got connection */
	SBUF_EV_FLUSH,		/* data is sent, buffer empty */
	SBUF_EV_PKT_CALLBACK,	/* next part of pkt data */
	SBUF_EV_TLS_READY	/* TLS was established */
} SBufEvent;
```

Ê≥®ÈáäÊØîËæÉÊòéÁ°Æ‰∫ÜÔºåÈúÄË¶ÅÊòéÁ°Æ‰∏§ÁÇπÔºö

1. pkt dataÊòØ‰ªÄ‰πàÔºüpacket data
2. TLSÊòØ‰ªÄ‰πàÔºü**Transport Layer Security** Ôºö Âä†ÂØÜÂÆâÂÖ®ÁöÑËøûÊé•

#### callback

```c
bool server_proto(SBuf *sbuf, SBufEvent evtype, struct MBuf *data)
```

### clientÁ´ØÁöÑcallback

```c
bool client_proto(SBuf *sbuf, SBufEvent evtype, struct MBuf *data)
```

ÂàÜÂà´Âá∫ÂàóclientÂíåserverÁ´ØËøûÊé•‰∏äÁöÑsbufÁöÑËØ∑Ê±ÇÔºõ

## SocketState

```c
/* each state corresponds to a list */
enum SocketState {
	CL_FREE,		/* free_client_list */
	CL_JUSTFREE,		/* justfree_client_list */
	CL_LOGIN,		/* login_client_list */
	CL_WAITING,		/* pool->waiting_client_list */
	CL_WAITING_LOGIN,	/*   - but return to CL_LOGIN instead of CL_ACTIVE */
	CL_ACTIVE,		/* pool->active_client_list */
	CL_CANCEL,		/* pool->cancel_req_list */

	SV_FREE,		/* free_server_list */
	SV_JUSTFREE,		/* justfree_server_list */
	SV_LOGIN,		/* pool->new_server_list */
	SV_IDLE,		/* pool->idle_server_list */
	SV_ACTIVE,		/* pool->active_server_list */
	SV_USED,		/* pool->used_server_list */
	SV_TESTED		/* pool->tested_server_list */
};
#define is_server_socket(sk) ((sk)->state >= SV_FREE)
```

Êûö‰∏æÂÄºÂ∫ïÂ±ÇÂ∞±ÊòØÊúâÂ∫èÁöÑÊï¥Êï∞ÂÄºÔºåÈÄöËøáÂÆè`is_server_socket(sk)`Âà§Êñ≠ÊòØclientËøòÊòØserverÁöÑsocketÔºõ

#### StateList

ÊØè‰∏™socketstateÂØπÂ∫î‰∏Ä‰∏™`StateList`ÔºåËøôÊòØ‰∏Ä‰∏™Â∏¶ÊúâÁªüËÆ°‰ø°ÊÅØÁöÑÂèåÂêëÈìæË°®ÔºåÁî®Êù•ÁªüËÆ°pgbouncer‰∏≠ÁöÑÂêÑ‰∏™Áä∂ÊÄÅÁöÑ‰ø°ÊÅØÔºå`show stats`ÂëΩ‰ª§ÁöÑÊï∞ÊçÆÊù•Ê∫êÔºåÂ¶Ç‰∏ãÂÆö‰πâÔºõ

```c
/**
 * Structure for both list nodes and heads.
 *
 * It is meant to be embedded in parent structure,
 * which can be acquired with container_of().
 */
struct List {
	/** Pointer to next node or head. */
	struct List *next;
	/** Pointer to previous node or head. */
	struct List *prev;
};

/** Define and initialize emtpy list head */
#define LIST(var) struct List var = { &var, &var }


/**
 * Header structure for StatList.
 */
struct StatList {
	/** Actual list head */
	struct List head;
	/** Count of objects currently in list */
	int cur_count;
#ifdef LIST_DEBUG
	/** List name */
	const char *name;
#endif
};

/** Define and initialize StatList head */
#ifdef LIST_DEBUG
#define STATLIST(var) struct StatList var = { {&var.head, &var.head}, 0, #var }
#else
#define STATLIST(var) struct StatList var = { {&var.head, &var.head}, 0 }
#endif
```

> ËøôÈáåÊúâ‰∏Ä‰∏™CËØ≠Ë®ÄÂÆèÁöÑÂ∞èÊäÄÂ∑ßÔºöCÁöÑÂÆèÂèØ‰ª•Â∏¶ÂèÇÊï∞Ôºå#var Ë°®Á§∫ÂèÇÊï∞ÂèòÊàê‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤Ôºõ##ËøûÊé•‰∏çÂêåÁöÑÂèÇÊï∞ÔºåÂΩ¢Êàê‰∏Ä‰∏™Êñ∞ÁöÑtokenÔºõ
>
> ```c
> STATLIST(my_list);
> ```
>
> ÈÄöËøá `gcc -E macros.c -D LIST_DEBUG`È™åËØÅ‰∏Ä‰∏ãÔºåÂèòÊàêÂ¶Ç‰∏ãÁöÑÂÆö‰πâÔºåÈÄöËøáÂÆèÁöÑÊäÄÂ∑ßÂèØ‰ª•Â∞ëÊï≤‰∏çÂ∞ë‰ª£Á†ÅüòÇ
>
> ```c
> struct StatList my_list = { {&my_list.head, &my_list.head}, 0, "my_list" };
> ```

## Packet Header ‰ø°ÊÅØ

```c
/* old style V2 header: len:4b code:4b */
#define OLD_HEADER_LEN	8
/* new style V3 packet header len - type:1b, len:4b */
#define NEW_HEADER_LEN	5

/*
 * parsed packet header, plus whatever data is
 * available in SBuf for this packet.
 *
 * if (pkt->len == mbuf_avail(&pkt->data))
 * 	packet is fully in buffer
 *
 * get_header() points pkt->data.pos after header.
 * to packet body.
 */
struct PktHdr {
	unsigned type;
	unsigned len;
	struct MBuf data;
};
```

Âú®ÂÖ∂‰∏≠typeÁ±ªÂûãÁî®ÂÆèÂÆö‰πâ‰∫Ü‰∏Ä‰∫õÁ±ªÂûãÔºö

```c
/* type codes for weird pkts */
#define PKT_STARTUP_V2  0x20000
#define PKT_STARTUP     0x30000
#define PKT_CANCEL      80877102
#define PKT_SSLREQ      80877103
```

MbufÂ∞±ÊòØMemory BufÔºåÂèØ‰ª•Â∞±ÊòØÂÜÖÂ≠òÁöÑ‰∏ÄÊÆµÂå∫ÂüüÔºåÂèØ‰ª•ÁêÜËß£ÊàêÊúÄÂ∫ïÂ±Çmalloc‰∏äÁöÑ‰∏ÄÂ±ÇÂ∞ÅË£ÖÔºõ

PktHdrÂ∞±ÊòØÂ∞ÜSbuf‰∏≠ÊØè‰∏™Packet HeaderËß£ÊûêÂêéÔºåÂ∞Ü‰ø°ÊÅØÊîæÂú®ËøôÈáåÔºåÂ¶ÇÊûúlenÁ≠â‰∫é`mbuf_avail(&pkt->data))`ÔºåÈÇ£‰πàËØ¥Êòépacket‰∏≠ÁöÑÊï∞ÊçÆÊòØÂÆåÊï¥ÁöÑÔºõ

`bool get_header(struct MBuf *data, PktHdr *pkt) _MUSTCHECK;` get_headerÊ£ÄÊü•packer headerÊ£ÄÊü•ÂÆåÊàêÂπ∂‰∏îÊàêÂäüÂêéÔºåÂ∞ÜÊú¨packer ÁöÑÊï∞ÊçÆÂ≠òÂÖ•pkt‰∏≠Ôºõ

> ÂÆö‰∫Ü_MUSTCHECKÊ≥®Ëß£ÔºåË°®Á§∫Ëøô‰∏™ÂáΩÊï∞ËøîÂõûÂÄºÂøÖÈ°ªË¶ÅÂ§ÑÁêÜÔºõ

## PostgreSQL Áõ∏ÂÖ≥ÁªìÊûÑ

##### PgSocket

+ PgAddr ÊòØ‰∏Ä‰∏™ËÅîÂêà‰ΩìÔºö ËÆ∞ÂΩï‰∫ÜpgserverÁöÑÂú∞ÂùÄ‰ø°ÊÅØÔºåÂèØ‰ª•ÊòØ ipv4 ipv6 unixsocketÔºàport+uid/pidÔºâ

```c
/*
 * A client or server connection.
 *
 * ->state corresponds to various lists the struct can be at.
 */
struct PgSocket {
	struct List head;		/* list header */
	PgSocket *link;		/* the dest of packets */
	PgPool *pool;		/* parent pool, if NULL not yet assigned */

	PgUser *auth_user;	/* presented login, for client it may differ from pool->user */

	int client_auth_type;	/* auth method decided by hba */

	SocketState state:8;	/* this also specifies socket location */

	bool ready:1;		/* server: accepts new query */
	bool idle_tx:1;		/* server: idling in tx */
	bool close_needed:1;	/* server: this socket must be closed ASAP */
	bool setting_vars:1;	/* server: setting client vars */
	bool exec_on_connect:1;	/* server: executing connect_query */
	bool resetting:1;	/* server: executing reset query from auth login; don't release on flush */
	bool copy_mode:1;	/* server: in copy stream, ignores any Sync packets */

	bool wait_for_welcome:1;/* client: no server yet in pool, cannot send welcome msg */
	bool wait_for_user_conn:1;/* client: waiting for auth_conn server connection */
	bool wait_for_user:1;	/* client: waiting for auth_conn query results */
	bool wait_for_auth:1;	/* client: waiting for external auth (PAM) to be completed */

	bool suspended:1;	/* client/server: if the socket is suspended */

	bool admin_user:1;	/* console client: has admin rights */
	bool own_user:1;	/* console client: client with same uid on unix socket */
	bool wait_for_response:1;/* console client: waits for completion of PAUSE/SUSPEND cmd */

	bool wait_sslchar:1;	/* server: waiting for ssl response: S/N */

	int expect_rfq_count;	/* client: count of ReadyForQuery packets client should see */

	usec_t connect_time;	/* when connection was made */
	usec_t request_time;	/* last activity time */
	usec_t query_start;	/* query start moment */
	usec_t xact_start;	/* xact start moment */
	usec_t wait_start;	/* waiting start moment */

	uint8_t cancel_key[BACKENDKEY_LEN]; /* client: generated, server: remote */
	PgAddr remote_addr;	/* ip:port for remote endpoint */
	PgAddr local_addr;	/* ip:port for local endpoint */

	union {
		struct DNSToken *dns_token;	/* ongoing request */
		PgDatabase *db;			/* cache db while doing auth query */
	};

	VarCache vars;		/* state of interesting server parameters */

	SBuf sbuf;		/* stream buffer, must be last */
};
```

##### PgPool

- PgStats; ÊØè‰∏™poolÁª¥Êä§‰∏Ä‰∏™, ÈáåÈù¢ËÆ∞ÂΩï‰∫ÜËøô‰∏™pool‰∏≠ÁöÑÁªüËÆ°‰ø°ÊÅØ
- PgDatabase: ÂØπÂ∫îpgbouncer.ini‰∏≠[database]È°πÁöÑÈÖçÁΩÆ‰ø°ÊÅØ
- PgUserÔºö ÂØπÂ∫îpgbouncer.ini‰∏≠[user]È°πÁöÑÈÖçÁΩÆ‰ø°ÊÅØ

```c
/*
 * Contains connections for one db+user pair.
 *
 * Stats:
 *   ->stats is updated online.
 *   for each stats_period:
 *   ->older_stats = ->newer_stats
 *   ->newer_stats = ->stats
 */
struct PgPool {
	struct List head;			/* entry in global pool_list */
	struct List map_head;			/* entry in user->pool_list */

	PgDatabase *db;			/* corresponding database */
	PgUser *user;			/* user logged in as */

	struct StatList active_client_list;	/* waiting events logged in clients */
	struct StatList waiting_client_list;	/* client waits for a server to be available */
	struct StatList cancel_req_list;	/* closed client connections with server key */

	struct StatList active_server_list;	/* servers linked with clients */
	struct StatList idle_server_list;	/* servers ready to be linked with clients */
	struct StatList used_server_list;	/* server just unlinked from clients */
	struct StatList tested_server_list;	/* server in testing process */
	struct StatList new_server_list;	/* servers in login phase */

	PgStats stats;
	PgStats newer_stats;
	PgStats older_stats;

	/* database info to be sent to client */
	struct PktBuf *welcome_msg; /* ServerParams without VarCache ones */

	VarCache orig_vars;		/* default params from server */

	usec_t last_lifetime_disconnect;/* last time when server_lifetime was applied */

	/* if last connect failed, there should be delay before next */
	usec_t last_connect_time;
	unsigned last_connect_failed:1;

	unsigned welcome_msg_ready:1;
};


```

#### Áªº‰∏ä

ÂÖ≥‰∫éPgÁöÑÊï∞ÊçÆÁªìÊûÑÔºå‰∏ªË¶ÅÊòØ‰∏Ä‰∏™PgpoolÔºåÊØïÁ´üËøôÂ∞±ÊòØËøûÊé•Ê±†‰∏≠Èó¥‰ª∂ÔºõÂÖ∂‰∏≠Áª¥Êä§‰∫ÜdatabaseÁöÑÈÖçÁΩÆÔºåuserÁöÑÈÖçÁΩÆÔºåÂπ∂‰∏îËÆ∞ÂΩï‰∫ÜpoolÁöÑÁªüËÆ°‰ø°ÊÅØÔºõÂè¶Â§ñÂÖ∂‰∏≠Âª∫Á´ã‰∫ÜÂíåserverÂíåclientÁöÑËøûÊé•ÔºåÊåâÁÖß‰∏çÂêåÁöÑÁä∂ÊÄÅÊîæÂú®‰∏çÂêåÁöÑlist‰∏≠Ôºõ
