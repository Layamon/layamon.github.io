---
layout: post
title: Process Models
subtitle: 译
date: 2018-06-20 20:45
header-img: "img/head.jpg"
categories: jekyll update
tags:
  - DB
typora-root-url: ../../yummyliu.github.io
---

在设计任何多用户服务器时，需要尽早做出关于如何执行并发的用户请求，以及这些请求和操作系统进程或线程如何对应的决定。 这些决策对系统的软件体系结构，以及跨操作系统的性能，可扩展性和可移植性有着深远的影响。在本节中，我们考察了DBMS Process Model的许多方案，这些方案对于其他高度并发的服务器系统是可以参考的模板。 我们从一个简化的框架开始，假设线程具有操作系统支持的良好的可用性，并且我们最初只针对单处理器系统。 然后，我们对这个简化的讨论进行推广，以讨论现代DBMS实际上如何实现其Process Model。 在第3节中，我们讨论利用计算机集群以及多处理器和多核系统的技术。

下面的讨论依赖于这些定义：

+ 进程将操作系统（OS）程序执行单元（控制线程）与该进程专用的地址空间相结合。 为进程维护的状态包括操作系统资源句柄和安全上下文。 这个单一的程序执行单元由OS内核调度，每个进程都有自己独特的地址空间。

+ 线程是OS程序执行单元，没有额外的私有操作系统上下文，也没有私有地址空间。 每个操作系统线程都可以完全访问在同一个多线程操作系统进程中执行的其他线程的内存。 线程执行由操作系统内核调度程序调度，这些线程通常称为“kernel threads”或k线程。

+ 轻量级线程包是一个应用程序级别的结构，支持单个OS进程中的多个线程。 与OS调度的OS线程不同，轻量级线程由应用程序级线程调度程序调度。 **轻量级线程和内核线程之间的区别**在于，在用户空间中调度轻量级线程，而无需内核调度程序参与或知晓。 用户空间调度程序及其所有轻量级线程的组合在单个OS进程中运行，并作为单个执行线程显示给OS调度程序。

  ​	与OS线程相比，轻量级线程具有更快的线程切换优势，因为不需要执行OS内核模式切换来安排下一个线程。 但是，轻量级线程的缺点是，任何线程的任何阻塞操作（例如同步I / O）都会阻塞进程中的所有线程。 这可以防止任何其他线程被一个等待OS资源的线程阻塞。 轻量级线程包通过（1）仅发布异步（非阻塞）I / O请求，和（2）不调用任何可能阻塞的操作系统操作来避免这种情况。 通常，轻量级线程提供比编写基于OS进程或OS线程的软件更困难的编程模型。

+ 一些DBMS实现自己的轻量级线程（LWT）包。 这些是一般LWT包的特例。 我们将这些线程称为DBMS线程；或者当DBMS，一般LWT和OS线程之间的区别并不重要时，我们统称这些为线程。

+ DBMS客户端是实现了与DBMS通信的API的软件组件。一些示例数据库访问API是JDBC，ODBC和OLE / DB。此外，还有各种各样的专有数据库访问API集。有些程序使用嵌入式SQL编写，这是一种将编程语言语句与数据库访问语句混合在一起的技术。这首先是在IBM COBOL和PL / I中提供的，后来在SQL / J中实现了Java的嵌入式SQL。嵌入式SQL由预处理器处理，可将嵌入式SQL语句转换为直接调用数据访问API。无论客户端程序中使用什么语法，最终结果都是对DBMS数据访问API的一系列调用。对这些API的调用由DBMS客户端组件封送并通过某种通信协议发送到DBMS。协议通常是专有的，通常没有文档。过去，为了标准化客户端到数据库通信协议已经做出了一些努力，Open Group DRDA可能是最着名的，但没有一个得到广泛采用。

+ DBMS Worker是代表DBMS客户端工作的DBMS中的执行线程。 DBMS工作者和DBMS客户端之间存在1：1映射：DBMS工作者处理来自单个DBMS客户端的所有SQL请求。 DBMS客户端将SQL请求发送到DBMS服务器。 worker执行每个请求并将结果返回给客户端。 在下文中，我们调查了商业DBMS用于将DBMS工作者映射到OS线程或进程上的不同方法。 当区别很大时，我们会将它们称为工作线程或工作进程。 否则，我们将它们简称为worker或DBMS worker。

# 2.1 单处理器和轻量级线程

​	在本小节中，我们概述了一个简化的DBMS Process Model类型。 几乎没有知名的数据库管理系统的架构采用本节所述的架构，但这些内容是我们进一步讨论当前生产架构的基础。 目前，每个知名的数据库系统的核心都是对这里介绍的至少一种模型的扩展或增强。

​	我们首先做出两个简化的假设（我们将在随后的章节中展开）：

1. 操作系统线程支持：我们假设操作系统为我们提供了对内核线程的有效支持，并且一个进程可以拥有非常多的线程。 我们还假定每个线程的内存开销很小，并且上下文切换是便宜的。 这在今天的许多现代操作系统中都可以证明是正确的，但当大多数DBMS首次设计时，这肯定不是真的。 由于操作系统线程在某些平台上不可用或不能很好地进行缩放，所以许多DBMS在不使用底层OS线程支持的情况下实现。
2. 单处理器硬件：我们将假设我们正在针对具有单CPU的单机设计一个DBMS。 鉴于多核系统的普及性，这是不切实际的假设。 然而，这个假设将简化我们的初步讨论。

在这个简化的上下文中，DBMS有三个自然的Process Model选择。 从最简单到最复杂，这些是：（1）每个DBMS worker一个进程，（2）每个DBMS worker一个线程，以及（3）进程池。 虽然这些模型都被简化了，但现在这三种模型都被商用DBMS系统所使用。

## 2.1.1 Process per DBMS worker

![](/image/ppw.jpeg)

​	process per worker（图2.1）被早期的DBMS实现所使用，并且今天仍然被许多商业系统使用。 由于DBMS worker直接映射到OS进程，因此该模型相对容易实现。 操作系统调度程序管理DBMS worker的调度，DBMS程序员可以依靠操作系统保护设施来隔离标准错误，如内存溢出。 而且，像调试器和存储器检查器这样的各种编程工具非常适合这种过程模型。 使这种模型复杂化的是跨DBMS连接共享的内存数据结构，包括锁定表和缓冲池（分别在第6.3节和第5.3节中详细讨论）。 这些共享数据结构必须在所有DBMS进程可访问的OS支持的共享内存中显式分配。 这需要OS支持（这是广泛可用的）和一些特殊的DBMS代码。在实践中，在这个模型中所需的大量共享内存的使用减少了地址空间分离的一些优点，因为跨进程共享了很多“有趣”的内存。

​	在扩展到大量并发连接方面，每个DBMS worker一个进程并不是最有吸引力的process model。 出现的扩展问题是因为进程比线程拥有更多的状态，因此会消耗更多的内存。 进程切换需要切换安全上下文，内存管理器状态，文件和网络句柄表以及其他进程上下文。 线程切换不需要。 尽管如此，process per worker仍然很流行，并且受到IBM DB2，PostgreSQL和Oracle的支持。

## 2.1.2 Thread per DBMS Worker

![](/image/tpw.jpeg)

在该模型中（图2.2），一个多线程进程负责所有DBMS worker的活动。一个或一小部分调度程序线程侦听新的DBMS客户端连接。每个连接都分配一个新的线程。当每个客户端提交SQL请求时，请求将完全由运行DBMS worker的相应线程执行。此线程在DBMS进程中运行，一旦完成，结果将返回给客户端，并且线程将等待来自同一客户端的下一个请求的连接。
	通常的多线程编程挑战出现在这种架构中：操作系统不能保护线程免受对方内存溢出和野指针的影响；调试非常棘手，特别是在竞争条件下；由于线程API和多线程扩展的差异，软件可能很难跨OS进行移植。由于大量使用共享内存，因此每个thread per worker中的许多多编程挑战也在process per worker中找到。
	尽管最近几年跨操作系统的线程API差异已经最小化，但跨平台的细微区别仍然会在调试和调优方面造成麻烦。忽略这些实现困难，thread per worker可以很好地扩展到大量的并发连接，并且用于当前的一些生产上的DBMS系统，包括IBM DB2，Microsoft SQL Server，MySQL，Informix和Sybase。

## 2.1.3 Process Pool 

![](/image/pool.png)

这个模型是process per worker的一个变体。回想一下，process per process 优势在于其实现简单。但每个连接需要一个完整的进程的内存开销是一个明显的缺点。通过进程池（图2.3），而不是为每个DBMS worker分配一个完整进程，而是由一组进程托管。一个中央进程保存所有的DBMS客户端连接，并且，由于每个SQL请求都来自客户端，所以请求被分配给进程池中的一个进程。 SQL语句一直执行完毕，结果返回给数据库客户端，并且进程返回到池中分配给下一个请求。进程池的大小是有限的并且通常是固定的。如果有请求进入，并且所有进程都在处理其他请求，则新请求必须等待进程可用。
	进程池具有process per worker的所有优点，但由于需要的进程数量少得多，因此显着提高了内存的效率。进程池通常使用可动态调整大小的进程池来实现，当大量并发请求到达时，池可能会增长到某个最大值。当请求负载更轻时，进程池可以减少到更少的等待进程。与thread per worker一样，process per worker也受当今使用的几个当代DBMS的支持。

## 2.1.4 Shared Data and Process Boundaries 

​	上述所有模型都旨在尽可能独立地执行并发客户端请求。 但是，完整的DBMS工作程序独立性和隔离性是不可能的，因为它们在相同的共享数据库上运行。 在thread per worker中，数据共享很容易，所有线程都在相同的地址空间中运行。 在其他模型中，共享内存用于共享数据结构和状态。 在所有三种模式中，数据必须从DBMS移到客户端。 这意味着所有的SQL请求都需要移入服务器进程，并且返回给客户端的所有结果都需要移出。 这是如何完成的？ 简单的答案是使用各种缓冲器。 两种主要类型是磁盘I / O缓冲区和客户端通信缓冲区。 我们在这里描述这些缓冲区，并简要讨论管理它们的策略。

​	**磁盘I / O缓冲区**：最常见的跨worker数据依赖性是对共享数据存储的读取和写入。 因此，DBMS工作者之间的I / O交互很常见。 有两种独立的磁盘I / O场景需要考虑：（1）数据库请求和（2）日志请求。

+ 数据库I / O请求：缓冲池。 所有持久性数据库数据都通过DBMS缓冲池进行缓存（第5.3节）。 对于 thread per worker中的worker，缓冲池只是一个在堆中存在的数据结构，可用在共享DBMS地址空间中的所有线程。 在另外两个模型中，缓冲池被分配到所有进程可用的共享内存中。 所有三种DBMS模型的最终结果是，缓冲池是可用于所有数据库线程和/或进程的大型共享数据结构。 当一个线程需要从数据库读入一个页面时，它会生成一个指定磁盘地址的I / O请求，以及缓冲池中可放置结果的空闲内存位置（帧）的句柄。 要将缓冲池页面刷新到磁盘，线程将生成一个I / O请求，该请求包含缓冲池中页面的当前帧和磁盘上的目标地址。 缓冲池在第4.3节中有更详细的讨论。

+ 日志I / O请求：日志跟踪(log tail)。数据库日志（第6.4节）是存储在一个或多个磁盘上的一组条目。由于日志条目是在事务处理期间生成的，因此它们被暂存到内存中的队列，该队列按照FIFO顺序定期刷新到日志磁盘。该队列通常称为日志跟踪。在许多系统中，单独的进程或线程负责定期将日志尾部清理到磁盘。

  ​	使用thread per worker模型，日志追踪就是一个堆中的数据结构。在另外两种模式中，两种不同的设计方案很常见。在一种方法中，一个单独的进程管理日志。日志记录通过共享内存或任何其他高效的进程间通信协议与日志管理器通信。在另一种方法中，日志追踪在共享内存中分配的方式与上面处理缓冲池的方式大致相同。关键在于执行数据库客户端请求的所有线程和/或进程都需要能够请求写入日志记录并刷新日志追踪。

  ​	一个重要的日志刷新类型是commit事务刷新。在commit日志记录刷新到日志设备之前，不能将事务报告为成功提交。这意味着客户端代码会一直等到提交日志记录被刷盘，并且DBMS服务器代码也必须持有所有资源（例如，锁），直到刷盘。日志刷盘请求可能会被推迟一段时间，以允许在单个I / O请求（“group commit”）中批量提交记录。

 	**客户端通信缓冲区**：通常在“pull”模型中使用SQL：客户端通过重复发出SQL FETCH请求来从查询游标中获取结果元组，该SQL FETCH请求会根据请求检索一个或多个元组。大多数DBMS尝试在FETCH请求流之前工作，以便在客户端请求之前准备好结果。

​	为了支持这种预取行为，DBMS工作者可以使用客户端通信套接字作为它产生的元组的队列。更复杂的方法实现客户端游标缓存，并使用DBMS客户端存储可能在不久的将来被取回的结果，而不是依赖于OS通信缓冲区。

​	**锁定表**：锁定表由所有DBMS worker共享，并由lock manager（第6.3节）用于实现数据库锁定语义。用于共享锁表的技术与共享缓冲池的技术相同，并且可以使用这些相同的技术来支持DBMS实现所需的任何其他共享数据结构。

## 2.2 DBMS Thread