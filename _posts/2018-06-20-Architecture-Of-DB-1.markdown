---
layout: post
title: (译)Process Models
subtitle: Architecture of a Database System —— Joseph M. Hellerstein1, Michael Stonebraker2 and James Hamilton3
date: 2018-05-20 20:45
header-img: "img/head.jpg"
categories: jekyll update
tags:
  - Paper
typora-root-url: ../../yummyliu.github.io
---

​	数据库管理系统（DBMS）是现代计算中无处不在的关键组件，也是学术界和工业界数十年研究和开发的成果。从历史上看，数据库管理系统是最早开发的多用户服务器系统之一，因此率先开发了许多系统设计技术，以便在许多其他环境中使用，以实现可扩展性和可靠性。尽管数据库管理系统使用的许多算法和概念都是教科书的材料，但关于使数据库管理系统工作的系统设计问题的文献中有相对稀少的报道。本文介绍了DBMS设计原则的架构讨论，包括

+ 进程模型
+ 并行体系结构
+ 存储系统设计
+ 事务系统实现
+ 查询处理器
+ 查询优化器体系结构
+ 其他典型的组件和工具。

并且参考一些成功的商业和开源系统，不同的组织基于不同的方案实现了DBMS。

# 1. 介绍

​	数据库管理系统（DBMS）是复杂的、关键的软件系统。 今天的DBMS体现了数十年的学术和工业研究以及紧锣密鼓的企业软件开发。 数据库系统是最早被广泛部署的在线服务器系统之一，因此，它已经率先推出了不仅包括数据管理，还包括应用程序，操作系统和网络服务的设计解决方案。 早期的数据库管理系统是计算机科学中最具影响力的软件系统之一，数据库管理系统开创的想法和实现问题，被广泛复制和重新创造。	

​	出于多种原因，数据库系统体系结构的教训并不像应该那样广为人知。 首先，实际的数据库系统社区相当小。 由于市场倾向于少数头部玩家，因此只有少数几个成功的DBMS实现方案存在。 参与设计和实现数据库系统的人关系十分紧密：许多人参加了同一所学校，参与了相同的有影响力的研究项目，并合作了相同的商业产品。 其次，对数据库系统的学术处理往往忽视了架构问题。在数据库系统的教科书陈述中，传统上主要集中在算法和理论问题上 —— 这对于教学，研究和测试来说是很自然的 —— 而没有在整体实现中，全面地讨论系统架构。 总而言之，关于如何构建数据库系统的许多传统知识是可用的，但其中很少被写下或广泛传播。	

​	在本文中，我们尝试抓住现代数据库系统架构设计的主要方面，并讨论高级主题。其中一些出现在文献中，我们在相应的地方给出了我们引用。其他问题被藏在在产品手册中，有些仅仅是社区口头传述的一部分。在适用的情况下，我们使用商业和开源系统作为讨论的各种架构形式的例子。然而，由于字数的限制，就不列举代码中的例外情况和细微差别，这其中大部分已经超过十年之久。我们的目标是关注整体系统设计和压力问题，而这些问题通常在教科书中没有讨论过，为更广为人知的算法和概念提供了有用的背景。我们假设读者熟悉教科书数据库系统知识（例如[72]或[83]）以及现代操作系统（如UNIX，Linux或Windows）的基础设施。在下一节中介绍了DBMS的高级架构之后，我们在第1.2节中的每个组件上提供了一些关于背景介绍的参考文献。

## 1.1 关系代数系统：查询的生命之源

![](/image/arch_db.jpeg)

​	目前生产中最成熟和应用最广泛的数据库系统是关系数据库管理系统（RDBMS）。 这些系统可以作为全球大部分应用基础设施的核心，包括电子商务，医疗记录，计费，人力资源，工资单，客户关系管理和供应链管理等等。 电商和社交网站的出现只增加了它们的使用量和应用场景。 关系系统充当几乎所有在线交易和大多数在线内容管理系统（博客，维基，社交网络等）背后的信息存储仓库。 除了作为重要的软件基础设施外，RDBMS还可以作为未来可能出现的DBMS新扩展和革命的容易理解的参考方案。 因此，我们在本文中关注关系数据库系统。

​	本质上，典型的RDBMS有五个主要组件，如图所示。 作为对这些组件的介绍以及它们的组合方式，我们逐步了解一个查询在数据库系统中的生命。 这也是本文其余部分的概述。

​	考虑一个简单但典型的机场数据库交互，检票员点击表格以查看乘客列表中的航班。 这个按钮点击会产生一个大致如下所示的单一查询事务：

1. CCM：机场门口的个人计算机（“客户”）调用API，然后通过网络进行通信，以建立与DBMS的Client Communications Manager（图的顶部）的连接。 在某些情况下，这个连接在客户端和数据库服务器之间直接建立，例如通过ODBC或JDBC连接协议。这种方式被称为“双层”或“CS”系统。在其他情况下，客户端可以与“中间层服务器”（web服务器，事务处理监视器等）进行通信，后者又使用协议来代理客户端和DBMS之间的通信。这通常被称为“三层”系统。在基于Web的许多情况下，Web服务器和DBMS之间还有另一个“应用程序服务器”层，从而产生四层。鉴于这些不同的选择，典型的DBMS需要与各种客户端驱动程序和中间件系统所使用的许多不同的连接协议兼容。但是，在所有这些协议中，Client Communications Manager的职责大致相同：**建立并记住调用者（不管它是客户端还是中间件服务器）的连接状态，以响应SQL来自调用者的命令，并且适当地返回数据和控制消息（结果代码，错误等）**。在我们的简单示例中，Client Communications Manager将建立客户端的安全凭证，设置状态以记录跨连接的新连接和当前SQL命令的详细信息，并将客户端的第一个请求进一步地转发到DBMS中进行处理。
2. PM：在收到客户端的第一条SQL命令后，DBMS必须为该命令分配一个“计算线程”。 它还必须确保线程的数据和控制输出通过CCM连接到客户端。 这些任务是DBMS Process Manager的工作（图的左侧）。 数据库管理系统在查询阶段需要做的最重要的决定是关于**准入控制**：系统是应该立即开始处理查询，还是推迟到有足够的系统资源可用于查询时，才执行。 我们在第2节详细讨论Process Manager。
3. RQP：一旦被接纳并分配为控制线程，检票员的查询就可以开始执行。 它通过调用Relational Query Processor中的代码（图的中心）来实现。 这组模块检查用户是否有权运行查询，并将用户的SQL查询文本编译为内部查询计划。 编译完成后，生成的查询计划将通过plan executer处理。 plan excuter包含一套用于执行任何查询的“运算符”（基于关系算法实现）。 典型的操作符实现了关系查询处理的任务，包括连接，选择，投影，聚合，排序等，以及从系统底层扫描数据的方法。 在我们的示例查询中，调用这些运算符的一小部分（由查询优化器组合）以满足检票员的查询。 我们在第4节讨论Query Processer。
4. 在检票员的查询计划的基础上，存在一个或多个运算符来从数据库请求数据。这些操作从DBMS的Transactional Storage Manager（图底部）获取数据，该模块管理所有数据访问（读取）和操作（创建，更新，删除）调用。存储系统包括用于组织和访问磁盘上数据的算法和数据结构（“access method”），包括表和索引等基本结构。它还包括一个buffer manager模块，用于决定在磁盘和内存缓冲区之间传输何时以及要传输什么数据。回到我们的例子，在基于access method访问数据的过程中，查询必须调用transactions代码以确保事务的众所周知的“ACID”属性 。在访问数据之前，从lock manager中获取锁以确保在其他并发查询面前正确执行。如果门户代理的查询涉及对数据库的更新，它将与log manager进行交互，以确保交易在提交时是**持久的**，如果中止则undo。在第5节中，我们将更详细地讨论存储和缓冲区管理;第6节介绍事务**一致性**体系结构。
5. 查询进行到这一步，它已经开始访问数据记录，并准备使用它们计算客户端的结果。这是通过“堆栈展开”我们描述的工作完成的。访问方法将控制权返回给查询执行器的操作，该操作员编排数据库数据的结果元组的计算;因为结果元组被生成，所以它们被放置在客户端通信管理器的缓冲区中，该管理器将结果发回给调用者。对于较大的结果集，客户端通常会进行额外的调用以从查询中增量获取更多数据，从而导致通过通信管理器，查询执行器和存储管理器进行多次迭代。在我们的简单例子中，在查询结束时，事务完成并且连接关闭;这会导致事务管理器清理事务的状态，流程管理器释放查询的任何控制结构，并且通信管理器清除连接的通信状态。

		我们对这个示例查询的讨论涉及了RDBMS中的许多关键组件，但不是全部。 图1.1的右侧描述了许多共享组件和实用程序，它们对于全功能DBMS的操作至关重要。 目录和内存管理器在任何事务处理过程中都被调用为工具，包括我们的示例查询。 查询处理器在验证，解析和查询优化期间使用该目录。 无论何时需要动态分配或释放内存，内存管理器都会用于整个DBMS。 图1.1最右边框中列出的其余模块是独立于任何特定查询运行的实用程序，使数据库整体保持良好调整和可靠。 我们在第7节讨论这些共享组件和实用程序。

## 1.2 概述

​	在本文的大部分内容中，我们将重点放在支持核心数据库功能的体系结构基础上。我们不试图对文献中大量记录的数据库算法进行综合评述。我们对现代数据库管理系统中许多扩展的讨论也只是极少讨论，其中大部分扩展提供了超越核心数据管理的功能，但不会显着改变系统架构。
我们开始讨论数据库系统的整体架构。任何服务器系统架构中的第一个主题是其整体流程结构，我们在这方面探索了各种可行的替代方案，首先针对单处理器机器，然后针对当今可用的各种并行架构。关于核心服务器系统体系结构的讨论适用于各种系统，但在数据库管理系统设计方面很有先例。接下来，我们从DBMS的更多特定于域的组件开始。我们从一个查询的系统视图开始，关注于关系查询处理器。随后，我们进入存储架构和事务性存储管理设计。最后，我们介绍大多数DBMS中存在的一些共享组件和实用程序，但很少在教科书中讨论。
在设计任何多用户服务器时，需要尽早做出关于如何执行并发的用户请求，以及这些请求和操作系统进程或线程如何对应的决定。 这些决策对系统的软件体系结构，以及跨操作系统的性能，可扩展性和可移植性有着深远的影响。在本节中，我们考察了DBMS Process Model的许多方案，这些方案对于其他高度并发的服务器系统是可以参考的模板。 我们从一个简化的框架开始，假设线程具有操作系统支持的良好的可用性，并且我们最初只针对单处理器系统。 然后，我们对这个简化的讨论进行推广，以讨论现代DBMS实际上如何实现其Process Model。 在第3节中，我们讨论利用计算机集群以及多处理器和多核系统的技术。

下面的讨论依赖于这些定义：

+ 进程将操作系统（OS）程序执行单元（控制线程）与该进程专用的地址空间相结合。 为进程维护的状态包括操作系统资源句柄和安全上下文。 这个单一的程序执行单元由OS内核调度，每个进程都有自己独特的地址空间。

+ 线程是OS程序执行单元，没有额外的私有操作系统上下文，也没有私有地址空间。 每个操作系统线程都可以完全访问在同一个多线程操作系统进程中执行的其他线程的内存。 线程执行由操作系统内核调度程序调度，这些线程通常称为“kernel threads”或k线程。

+ 轻量级线程包是一个应用程序级别的结构，支持单个OS进程中的多个线程。 与OS调度的OS线程不同，轻量级线程由应用程序级线程调度程序调度。 **轻量级线程和内核线程之间的区别**在于，在用户空间中调度轻量级线程，而无需内核调度程序参与或知晓。 用户空间调度程序及其所有轻量级线程的组合在单个OS进程中运行，并作为单个执行线程显示给OS调度程序。

  ​	与OS线程相比，轻量级线程具有更快的线程切换优势，因为不需要执行OS内核模式切换来安排下一个线程。 但是，轻量级线程的缺点是，任何线程的任何阻塞操作（例如同步I / O）都会阻塞进程中的所有线程。 这可以防止任何其他线程被一个等待OS资源的线程阻塞。 轻量级线程包通过（1）仅发布异步（非阻塞）I / O请求，和（2）不调用任何可能阻塞的操作系统操作来避免这种情况。 通常，轻量级线程提供比编写基于OS进程或OS线程的软件更困难的编程模型。

+ 一些DBMS实现自己的轻量级线程（LWT）包。 这些是一般LWT包的特例。 我们将这些线程称为DBMS线程；或者当DBMS，一般LWT和OS线程之间的区别并不重要时，我们统称这些为线程。

+ DBMS客户端是实现了与DBMS通信的API的软件组件。一些示例数据库访问API是JDBC，ODBC和OLE / DB。此外，还有各种各样的专有数据库访问API集。有些程序使用嵌入式SQL编写，这是一种将编程语言语句与数据库访问语句混合在一起的技术。这首先是在IBM COBOL和PL / I中提供的，后来在SQL / J中实现了Java的嵌入式SQL。嵌入式SQL由预处理器处理，可将嵌入式SQL语句转换为直接调用数据访问API。无论客户端程序中使用什么语法，最终结果都是对DBMS数据访问API的一系列调用。对这些API的调用由DBMS客户端组件封送并通过某种通信协议发送到DBMS。协议通常是专有的，通常没有文档。过去，为了标准化客户端到数据库通信协议已经做出了一些努力，Open Group DRDA可能是最着名的，但没有一个得到广泛采用。

+ DBMS Worker是代表DBMS客户端工作的DBMS中的执行线程。 DBMS工作者和DBMS客户端之间存在1：1映射：DBMS工作者处理来自单个DBMS客户端的所有SQL请求。 DBMS客户端将SQL请求发送到DBMS服务器。 worker执行每个请求并将结果返回给客户端。 在下文中，我们调查了商业DBMS用于将DBMS工作者映射到OS线程或进程上的不同方法。 当区别很大时，我们会将它们称为工作线程或工作进程。 否则，我们将它们简称为worker或DBMS worker。


# 2.1 单处理器和轻量级线程

​	在本小节中，我们概述了一个简化的DBMS Process Model类型。 几乎没有知名的数据库管理系统的架构采用本节所述的架构，但这些内容是我们进一步讨论当前生产架构的基础。 目前，每个知名的数据库系统的核心都是对这里介绍的至少一种模型的扩展或增强。

​	我们首先做出两个简化的假设（我们将在随后的章节中展开）：

1. 操作系统线程支持：我们假设操作系统为我们提供了对内核线程的有效支持，并且一个进程可以拥有非常多的线程。 我们还假定每个线程的内存开销很小，并且上下文切换是便宜的。 这在今天的许多现代操作系统中都可以证明是正确的，但当大多数DBMS首次设计时，这肯定不是真的。 由于操作系统线程在某些平台上不可用或不能很好地进行缩放，所以许多DBMS在不使用底层OS线程支持的情况下实现。
2. 单处理器硬件：我们将假设我们正在针对具有单CPU的单机设计一个DBMS。 鉴于多核系统的普及性，这是不切实际的假设。 然而，这个假设将简化我们的初步讨论。

在这个简化的上下文中，DBMS有三个自然的Process Model选择。 从最简单到最复杂，这些是：（1）每个DBMS worker一个进程，（2）每个DBMS worker一个线程，以及（3）进程池。 虽然这些模型都被简化了，但现在这三种模型都被商用DBMS系统所使用。

## 2.1.1 Process per DBMS worker

![](/image/ppw.jpeg)

​	process per worker（图2.1）被早期的DBMS实现所使用，并且今天仍然被许多商业系统使用。 由于DBMS worker直接映射到OS进程，因此该模型相对容易实现。 操作系统调度程序管理DBMS worker的调度，DBMS程序员可以依靠操作系统保护设施来隔离标准错误，如内存溢出。 而且，像调试器和存储器检查器这样的各种编程工具非常适合这种过程模型。 使这种模型复杂化的是跨DBMS连接共享的内存数据结构，包括锁定表和缓冲池（分别在第6.3节和第5.3节中详细讨论）。 这些共享数据结构必须在所有DBMS进程可访问的OS支持的共享内存中显式分配。 这需要OS支持（这是广泛可用的）和一些特殊的DBMS代码。在实践中，在这个模型中所需的大量共享内存的使用减少了地址空间分离的一些优点，因为跨进程共享了很多“有趣”的内存。

​	在扩展到大量并发连接方面，每个DBMS worker一个进程并不是最有吸引力的process model。 出现的扩展问题是因为进程比线程拥有更多的状态，因此会消耗更多的内存。 进程切换需要切换安全上下文，内存管理器状态，文件和网络句柄表以及其他进程上下文。 线程切换不需要。 尽管如此，process per worker仍然很流行，并且受到IBM DB2，PostgreSQL和Oracle的支持。

## 2.1.2 Thread per DBMS Worker

![](/image/tpw.jpeg)

在该模型中（图2.2），一个多线程进程负责所有DBMS worker的活动。一个或一小部分调度程序线程侦听新的DBMS客户端连接。每个连接都分配一个新的线程。当每个客户端提交SQL请求时，请求将完全由运行DBMS worker的相应线程执行。此线程在DBMS进程中运行，一旦完成，结果将返回给客户端，并且线程将等待来自同一客户端的下一个请求的连接。
	通常的多线程编程挑战出现在这种架构中：操作系统不能保护线程免受对方内存溢出和野指针的影响；调试非常棘手，特别是在竞争条件下；由于线程API和多线程扩展的差异，软件可能很难跨OS进行移植。由于大量使用共享内存，因此每个thread per worker中的许多多编程挑战也在process per worker中找到。
	尽管最近几年跨操作系统的线程API差异已经最小化，但跨平台的细微区别仍然会在调试和调优方面造成麻烦。忽略这些实现困难，thread per worker可以很好地扩展到大量的并发连接，并且用于当前的一些生产上的DBMS系统，包括IBM DB2，Microsoft SQL Server，MySQL，Informix和Sybase。

## 2.1.3 Process Pool 

![](/image/pool.png)

这个模型是process per worker的一个变体。回想一下，process per process 优势在于其实现简单。但每个连接需要一个完整的进程的内存开销是一个明显的缺点。通过进程池（图2.3），而不是为每个DBMS worker分配一个完整进程，而是由一组进程托管。一个中央进程保存所有的DBMS客户端连接，并且，由于每个SQL请求都来自客户端，所以请求被分配给进程池中的一个进程。 SQL语句一直执行完毕，结果返回给数据库客户端，并且进程返回到池中分配给下一个请求。进程池的大小是有限的并且通常是固定的。如果有请求进入，并且所有进程都在处理其他请求，则新请求必须等待进程可用。
	进程池具有process per worker的所有优点，但由于需要的进程数量少得多，因此显着提高了内存的效率。进程池通常使用可动态调整大小的进程池来实现，当大量并发请求到达时，池可能会增长到某个最大值。当请求负载更轻时，进程池可以减少到更少的等待进程。与thread per worker一样，process per worker也受当今使用的几个当代DBMS的支持。

## 2.1.4 Shared Data and Process Boundaries 

​	上述所有模型都旨在尽可能独立地执行并发客户端请求。 但是，完整的DBMS工作程序独立性和隔离性是不可能的，因为它们在相同的共享数据库上运行。 在thread per worker中，数据共享很容易，所有线程都在相同的地址空间中运行。 在其他模型中，共享内存用于共享数据结构和状态。 在所有三种模式中，数据必须从DBMS移到客户端。 这意味着所有的SQL请求都需要移入服务器进程，并且返回给客户端的所有结果都需要移出。 这是如何完成的？ 简单的答案是使用各种缓冲器。 两种主要类型是磁盘I / O缓冲区和客户端通信缓冲区。 我们在这里描述这些缓冲区，并简要讨论管理它们的策略。

​	**磁盘I / O缓冲区**：最常见的跨worker数据依赖性是对共享数据存储的读取和写入。 因此，DBMS工作者之间的I / O交互很常见。 有两种独立的磁盘I / O场景需要考虑：（1）数据库请求和（2）日志请求。

+ 数据库I / O请求：缓冲池。 所有持久性数据库数据都通过DBMS缓冲池进行缓存（第5.3节）。 对于 thread per worker中的worker，缓冲池只是一个在堆中存在的数据结构，可用在共享DBMS地址空间中的所有线程。 在另外两个模型中，缓冲池被分配到所有进程可用的共享内存中。 所有三种DBMS模型的最终结果是，缓冲池是可用于所有数据库线程和/或进程的大型共享数据结构。 当一个线程需要从数据库读入一个页面时，它会生成一个指定磁盘地址的I / O请求，以及缓冲池中可放置结果的空闲内存位置（帧）的句柄。 要将缓冲池页面刷新到磁盘，线程将生成一个I / O请求，该请求包含缓冲池中页面的当前帧和磁盘上的目标地址。 缓冲池在第4.3节中有更详细的讨论。

+ 日志I / O请求：日志跟踪(log tail)。数据库日志（第6.4节）是存储在一个或多个磁盘上的一组条目。由于日志条目是在事务处理期间生成的，因此它们被暂存到内存中的队列，该队列按照FIFO顺序定期刷新到日志磁盘。该队列通常称为日志跟踪。在许多系统中，单独的进程或线程负责定期将日志尾部清理到磁盘。

  ​	使用thread per worker模型，日志追踪就是一个堆中的数据结构。在另外两种模式中，两种不同的设计方案很常见。在一种方法中，一个单独的进程管理日志。日志记录通过共享内存或任何其他高效的进程间通信协议与日志管理器通信。在另一种方法中，日志追踪在共享内存中分配的方式与上面处理缓冲池的方式大致相同。关键在于执行数据库客户端请求的所有线程和/或进程都需要能够请求写入日志记录并刷新日志追踪。

  ​	一个重要的日志刷新类型是commit事务刷新。在commit日志记录刷新到日志设备之前，不能将事务报告为成功提交。这意味着客户端代码会一直等到提交日志记录被刷盘，并且DBMS服务器代码也必须持有所有资源（例如，锁），直到刷盘。日志刷盘请求可能会被推迟一段时间，以允许在单个I / O请求（“group commit”）中批量提交记录。

​	**客户端通信缓冲区**：通常在“pull”模型中使用SQL：客户端通过重复发出SQL FETCH请求来从查询游标中获取结果元组，该SQL FETCH请求会根据请求检索一个或多个元组。大多数DBMS尝试在FETCH请求流之前工作，以便在客户端请求之前准备好结果。

为了支持这种预取行为，DBMS工作者可以使用客户端通信套接字作为它产生的元组的队列。更复杂的方法实现客户端游标缓存，并使用DBMS客户端存储可能在不久的将来被取回的结果，而不是依赖于OS通信缓冲区。

​	**锁定表**：锁定表由所有DBMS worker共享，并由lock manager（第6.3节）用于实现数据库锁定语义。用于共享锁表的技术与共享缓冲池的技术相同，并且可以使用这些相同的技术来支持DBMS实现所需的任何其他共享数据结构。

## 2.2 DBMS Thread

上一节提供了DBMS Process Model的简化描述。 我们假定了**高性能的OS线程是可用的**，并且**数据库管理系统将只针对单处理器系统**。 在本节的其余部分中，我们放宽第一个假设并描述对DBMS实现的影响。 下一节将讨论多进程和并行处理。

### 2.2.1 DBMS Thread

​	今天的大多数数据库管理系统都来自20世纪70年代的研究系统和20世纪80年代的商业化工作。 我们认为理所当然的标准操作系统特性在DBMS开发人员建立原始数据库系统时通常无法使用。 高效率，高规模的OS线程支持可能是其中最重要的。 直到20世纪90年代，OS才得到广泛实施，并且在实际存在的情况下，实现方式差异很大。 即使在今天，一些OS线程的实现也不能很好地扩展到足以支持所有DBMS工作负载。

​	因此，出于传统，可移植性和可伸缩性的原因，许多广泛使用的DBMS在其实现中不依赖于OS线程。 一些完全避免线程，并使用process per worker或者process pool的方式。 那些基于其他process model 实现的方案（thread per worker）需要针对那些没有好的内核线程实现的操作系统的解决方案。 解决这个问题的几个主要的DBMS采用的一种方法是实现他们自己的专有的轻量级线程包。 这些轻量级线程或DBMS线程取代了上一节中描述的OS线程的角色。 这些线程包中，每个DBMS thread管理其自己的状态，通过非阻塞异步接口执行所有可能的阻塞操作（例如I / O），并频繁地将控制权交给分派任务的调度者。

​	轻量级线程是一个古老的想法，并广泛用于user interface中的event-loop编程。这种架构提供了快速任务切换和移植的简便性，代价是在DBMS中复制了大量的操作系统逻辑（任务切换，线程状态管理，调度等）[86]。

## 2.3 标准实现

在今天的领先数据库管理系统中，我们发现了第2.1节介绍的所有三种体系结构的代表以及其中一些有趣的变化。在这个层面上，IBM DB2可能是最有兴趣的例子，因为它支持四种不同的Process Model。在具有良好线程支持的操作系统上，DB2默认为thread per worker，并可选择支持在线程池复用worker。当在没有scalable thread 支持的操作系统上运行时，DB2默认为process per worker，并且可选地支持在进程池复用worker。
总结IBM DB2，MySQL，Oracle，PostgreSQL和Microsoft SQL Server支持的流程模型：

**process per worker**：
这是最直接的Process Model，今天仍然被大量使用。 DB2默认为在不支持高质量，可伸缩操作系统线程的操作系统上运行每个DBMS工作程序，并在每个DBMS工作线程上运行线程。这也是默认的Oracle方案。 Oracle还支持如下所述的process pool作为可选模型。 PostgreSQL为process per worker。

**thread per worker**：有两个变体

1. os thread per worker：在具有良好OS线程支持的系统上运行时，IBM DB2默认使用此模型，这是MySQL使用的模型。
2. dbms thread per worker：在此模型中，DBMS worker由OS进程或OS线程上的轻量级线程调度程序调度。该模型避免了任何潜在的操作系统调度程序扩展或性能问题，代价是实现成本高，开发工具支持较差以及DBMS供应商需要后期的软件维护。这个模型有两个主要的子类别：
   1. 在OS进程上调度的DBMS线程：轻量级线程调度程序由一个或多个OS进程托管。 Sybase和Informix一样支持这种模式。所有使用此模型的当代系统都实现了一个DBMS线程调度程序，该调度程序通过多个OS进程调度DBMS工作程序以利用多个处理器。但是，并非所有使用此模型的DBMS都实现了线程迁移（thread migration  ）：能够将现有DBMS线程重新分配给不同的OS进程（例如，用于负载平衡）。
   2. 在OS线程上调度的DBMS线程：Microsoft SQL Server支持将此模型作为非默认选项（默认情况是DBMS工作线程在下面描述的线程池上进行多路复用）。这种称为Fibers的SQL Server选项，用于某些高级事务处理基准测试，但否则使用相当少。

**process pool/thread pool：**
在此模型中，DBMS工作人员通过一系列进程进行复用。随着OS线程支持的改进，该模型的第二种变体已经基于线程池而不是进程池出现。在后一种模式中，DBMS工作人员通过OS线程池进行复用：

1. DBMS workers multiplexed over a process pool 

   该模型比process per worker具有更高的内存利用率，可以在没有良好OS线程支持的情况下轻松移植到OS，并且可以很好地扩展到大量用户。这是Oracle支持的可选模型，以及它们为具有大量同时连接的用户的系统所推荐的模型。 Oracle默认模型是process per worker。 Oracle支持的两种选项很容易支持它们定位的大量不同操作系统（Oracle支持的目标操作系统超过80种）。

2. DBMS workers multiplexed over a thread pool 

  Microsoft SQL Server默认使用此模型，超过99％的SQL Server安装以此方式运行。为了有效地支持数以万计的并发连接用户，如上所述，SQL Server可以选择支持在OS线程上调度的DBMS线程。
  正如我们在下一节中讨论的，大多数当代商用DBMS支持查询内并行：能够并行地在多个处理器上执行全部或部分单个查询。查询内并行性是将多个DBMS工作者临时分配给单个SQL查询。除了单个客户端连接可能有多个worker来执行之外，其他任何方式都不会影响底层的Process Model。

## 2.4 准入控制

在本章的结尾，我们阐述一下并发访问中剩下的一个问题。 随着任何多用户系统中的工作负载增加，吞吐量将增加到某个最大值。 超过这个点，随着系统开始抖动，它吞吐量将开始大幅下降。 与OS一样，性能抖动往往是内存压力的结果。DBMS不能将缓冲池中的数据库页面的“工作集”保留下来，并且花费所有时间来做页面替换。在DBMS中，查询处理技术尤其是排序和散列连接等查询处理技术会消耗大量内存。在某些情况下，由于争用锁也可能发生DBMS抖动：事务之间不断发生死锁，需要回滚并重新启动。因此，任何好的多用户系统都有一个**准入控制策略**，除非有足够的DBMS资源可用，否则它不接受新的工作。通过良好的准入控制器，系统将在过载情况下显示优雅的**降级**：**交易延迟将随着到达率成比例地增加，但吞吐量将保持在峰值。**

DBMS的准入控制可以在两层完成。首先，简单的准入控制策略可能在调度程序过程中，以确保客户端连接的数量保持在阈值以下。这用于防止像网络连接这样的基本资源过度消耗。在某些DBMS中，假设它是由另一个多层系统处理的，例如应用程序服务器，事务处理监视器或Web服务器。

​	第二层准入控制必须直接在核心DBMS关系查询处理器内实现。这个准入控制器的执行在查询被分析和优化之后，并确定查询是否被推迟，而后或者以更少的资源开始执行，或者没有资源限制的执行。准入控制器的执行由查询优化器提供的信息来辅助，该信息用于估计查询将需要的资源以及系统资源的当前可用性。特别是，优化器的查询计划可以指定（1）查询将访问的磁盘设备，以及每个设备的随机和顺序I / O数量的估计；（2）基于查询计划中的操作符和要处理的元组数量估计的查询的CPU负载；最重要的是（3）有关查询数据结构的内存占用情况的估计，包括用于在连接和其他查询执行任务期间对大量输入进行排序和散列的内存空间。如上所述，**这个最后的度量通常是准入控制器的关键**，因为内存压力通常是抖动的主要原因。因此，许多DBMS使用**内存占用量**和**活动worker**作为准入控制的主要标准。

## 2.5 额外讨论

Process Model的选择对DBMS的可扩展性和可移植性具有重大影响。因此，三个更广泛使用的商业系统在其产品线上支持多个process model。从工程角度来看，在所有操作系统和所有级别上采用单一的process model显然会更简单。但是，由于使用场景的多样性和目标操作系统的不一致性，这三个商业DBMS中的每一个都选择支持多个实现方式。

​	展望未来，由于硬件瓶颈的变化以及因特网负载的规模和多变性，近年来，服务器系统的新Process Model引起了人们的极大兴趣。这些设计中出现的一个主题是将服务器系统分解为一组独立调度的“引擎”，并在这些引擎之间异步传递消息。这就像上面的“进程池”模型，因为worker unit在多个请求中被重用。最近这项研究的主要创新之处在于，以比以前更小的任务指定方式，打破了系统功能的工作粒度。这导致了worker和SQL请求之间的多对多关系 - 通过多个工作者中的活动来处理单个查询，并且每个工作者针对许多SQL请求执行其自己的专用任务。这种架构可以实现更灵活的调度选择 - 例如，它允许动态权衡任务的执行方式，或者单个worker完成许多查询的任务（可能提高总体系统吞吐量），或着允许查询在多个worker中进行处理，进行动态权衡（以提高该查询的延迟）。在某些情况下，这已被证明在利用处理器高速缓存局部性方面具有优势，在cpu缓存没有命中的时候，能有效地减少CPU的闲置时间。在DBMS背景中中进一步研究这个想法的代表是StagedDB研究项目，可以进一步阅读。
