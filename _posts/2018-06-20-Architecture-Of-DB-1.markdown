---
layout: post
title: (译)Process Models
subtitle: Architecture of a Database System —— Joseph M. Hellerstein1, Michael Stonebraker2 and James Hamilton3
date: 2018-05-20 20:45
header-img: "img/head.jpg"
categories: jekyll update
tags:
  - paper
  - DB
typora-root-url: ../../yummyliu.github.io
---

在设计任何多用户服务器时，需要尽早做出关于如何执行并发的用户请求，以及这些请求和操作系统进程或线程如何对应的决定。 这些决策对系统的软件体系结构，以及跨操作系统的性能，可扩展性和可移植性有着深远的影响。在本节中，我们考察了DBMS Process Model的许多方案，这些方案对于其他高度并发的服务器系统是可以参考的模板。 我们从一个简化的框架开始，假设线程具有操作系统支持的良好的可用性，并且我们最初只针对单处理器系统。 然后，我们对这个简化的讨论进行推广，以讨论现代DBMS实际上如何实现其Process Model。 在第3节中，我们讨论利用计算机集群以及多处理器和多核系统的技术。

下面的讨论依赖于这些定义：

+ 进程将操作系统（OS）程序执行单元（控制线程）与该进程专用的地址空间相结合。 为进程维护的状态包括操作系统资源句柄和安全上下文。 这个单一的程序执行单元由OS内核调度，每个进程都有自己独特的地址空间。

+ 线程是OS程序执行单元，没有额外的私有操作系统上下文，也没有私有地址空间。 每个操作系统线程都可以完全访问在同一个多线程操作系统进程中执行的其他线程的内存。 线程执行由操作系统内核调度程序调度，这些线程通常称为“kernel threads”或k线程。

+ 轻量级线程包是一个应用程序级别的结构，支持单个OS进程中的多个线程。 与OS调度的OS线程不同，轻量级线程由应用程序级线程调度程序调度。 **轻量级线程和内核线程之间的区别**在于，在用户空间中调度轻量级线程，而无需内核调度程序参与或知晓。 用户空间调度程序及其所有轻量级线程的组合在单个OS进程中运行，并作为单个执行线程显示给OS调度程序。

  ​	与OS线程相比，轻量级线程具有更快的线程切换优势，因为不需要执行OS内核模式切换来安排下一个线程。 但是，轻量级线程的缺点是，任何线程的任何阻塞操作（例如同步I / O）都会阻塞进程中的所有线程。 这可以防止任何其他线程被一个等待OS资源的线程阻塞。 轻量级线程包通过（1）仅发布异步（非阻塞）I / O请求，和（2）不调用任何可能阻塞的操作系统操作来避免这种情况。 通常，轻量级线程提供比编写基于OS进程或OS线程的软件更困难的编程模型。

+ 一些DBMS实现自己的轻量级线程（LWT）包。 这些是一般LWT包的特例。 我们将这些线程称为DBMS线程；或者当DBMS，一般LWT和OS线程之间的区别并不重要时，我们统称这些为线程。

+ DBMS客户端是实现了与DBMS通信的API的软件组件。一些示例数据库访问API是JDBC，ODBC和OLE / DB。此外，还有各种各样的专有数据库访问API集。有些程序使用嵌入式SQL编写，这是一种将编程语言语句与数据库访问语句混合在一起的技术。这首先是在IBM COBOL和PL / I中提供的，后来在SQL / J中实现了Java的嵌入式SQL。嵌入式SQL由预处理器处理，可将嵌入式SQL语句转换为直接调用数据访问API。无论客户端程序中使用什么语法，最终结果都是对DBMS数据访问API的一系列调用。对这些API的调用由DBMS客户端组件封送并通过某种通信协议发送到DBMS。协议通常是专有的，通常没有文档。过去，为了标准化客户端到数据库通信协议已经做出了一些努力，Open Group DRDA可能是最着名的，但没有一个得到广泛采用。

+ DBMS Worker是代表DBMS客户端工作的DBMS中的执行线程。 DBMS工作者和DBMS客户端之间存在1：1映射：DBMS工作者处理来自单个DBMS客户端的所有SQL请求。 DBMS客户端将SQL请求发送到DBMS服务器。 worker执行每个请求并将结果返回给客户端。 在下文中，我们调查了商业DBMS用于将DBMS工作者映射到OS线程或进程上的不同方法。 当区别很大时，我们会将它们称为工作线程或工作进程。 否则，我们将它们简称为worker或DBMS worker。

# 2.1 单处理器和轻量级线程

​	在本小节中，我们概述了一个简化的DBMS Process Model类型。 几乎没有知名的数据库管理系统的架构采用本节所述的架构，但这些内容是我们进一步讨论当前生产架构的基础。 目前，每个知名的数据库系统的核心都是对这里介绍的至少一种模型的扩展或增强。

​	我们首先做出两个简化的假设（我们将在随后的章节中展开）：

1. 操作系统线程支持：我们假设操作系统为我们提供了对内核线程的有效支持，并且一个进程可以拥有非常多的线程。 我们还假定每个线程的内存开销很小，并且上下文切换是便宜的。 这在今天的许多现代操作系统中都可以证明是正确的，但当大多数DBMS首次设计时，这肯定不是真的。 由于操作系统线程在某些平台上不可用或不能很好地进行缩放，所以许多DBMS在不使用底层OS线程支持的情况下实现。
2. 单处理器硬件：我们将假设我们正在针对具有单CPU的单机设计一个DBMS。 鉴于多核系统的普及性，这是不切实际的假设。 然而，这个假设将简化我们的初步讨论。

在这个简化的上下文中，DBMS有三个自然的Process Model选择。 从最简单到最复杂，这些是：（1）每个DBMS worker一个进程，（2）每个DBMS worker一个线程，以及（3）进程池。 虽然这些模型都被简化了，但现在这三种模型都被商用DBMS系统所使用。

## 2.1.1 Process per DBMS worker

![](/image/ppw.jpeg)

​	process per worker（图2.1）被早期的DBMS实现所使用，并且今天仍然被许多商业系统使用。 由于DBMS worker直接映射到OS进程，因此该模型相对容易实现。 操作系统调度程序管理DBMS worker的调度，DBMS程序员可以依靠操作系统保护设施来隔离标准错误，如内存溢出。 而且，像调试器和存储器检查器这样的各种编程工具非常适合这种过程模型。 使这种模型复杂化的是跨DBMS连接共享的内存数据结构，包括锁定表和缓冲池（分别在第6.3节和第5.3节中详细讨论）。 这些共享数据结构必须在所有DBMS进程可访问的OS支持的共享内存中显式分配。 这需要OS支持（这是广泛可用的）和一些特殊的DBMS代码。在实践中，在这个模型中所需的大量共享内存的使用减少了地址空间分离的一些优点，因为跨进程共享了很多“有趣”的内存。

​	在扩展到大量并发连接方面，每个DBMS worker一个进程并不是最有吸引力的process model。 出现的扩展问题是因为进程比线程拥有更多的状态，因此会消耗更多的内存。 进程切换需要切换安全上下文，内存管理器状态，文件和网络句柄表以及其他进程上下文。 线程切换不需要。 尽管如此，process per worker仍然很流行，并且受到IBM DB2，PostgreSQL和Oracle的支持。

## 2.1.2 Thread per DBMS Worker

![](/image/tpw.jpeg)

在该模型中（图2.2），一个多线程进程负责所有DBMS worker的活动。一个或一小部分调度程序线程侦听新的DBMS客户端连接。每个连接都分配一个新的线程。当每个客户端提交SQL请求时，请求将完全由运行DBMS worker的相应线程执行。此线程在DBMS进程中运行，一旦完成，结果将返回给客户端，并且线程将等待来自同一客户端的下一个请求的连接。
	通常的多线程编程挑战出现在这种架构中：操作系统不能保护线程免受对方内存溢出和野指针的影响；调试非常棘手，特别是在竞争条件下；由于线程API和多线程扩展的差异，软件可能很难跨OS进行移植。由于大量使用共享内存，因此每个thread per worker中的许多多编程挑战也在process per worker中找到。
	尽管最近几年跨操作系统的线程API差异已经最小化，但跨平台的细微区别仍然会在调试和调优方面造成麻烦。忽略这些实现困难，thread per worker可以很好地扩展到大量的并发连接，并且用于当前的一些生产上的DBMS系统，包括IBM DB2，Microsoft SQL Server，MySQL，Informix和Sybase。

## 2.1.3 Process Pool 

![](/image/pool.png)

这个模型是process per worker的一个变体。回想一下，process per process 优势在于其实现简单。但每个连接需要一个完整的进程的内存开销是一个明显的缺点。通过进程池（图2.3），而不是为每个DBMS worker分配一个完整进程，而是由一组进程托管。一个中央进程保存所有的DBMS客户端连接，并且，由于每个SQL请求都来自客户端，所以请求被分配给进程池中的一个进程。 SQL语句一直执行完毕，结果返回给数据库客户端，并且进程返回到池中分配给下一个请求。进程池的大小是有限的并且通常是固定的。如果有请求进入，并且所有进程都在处理其他请求，则新请求必须等待进程可用。
	进程池具有process per worker的所有优点，但由于需要的进程数量少得多，因此显着提高了内存的效率。进程池通常使用可动态调整大小的进程池来实现，当大量并发请求到达时，池可能会增长到某个最大值。当请求负载更轻时，进程池可以减少到更少的等待进程。与thread per worker一样，process per worker也受当今使用的几个当代DBMS的支持。

## 2.1.4 Shared Data and Process Boundaries 

​	上述所有模型都旨在尽可能独立地执行并发客户端请求。 但是，完整的DBMS工作程序独立性和隔离性是不可能的，因为它们在相同的共享数据库上运行。 在thread per worker中，数据共享很容易，所有线程都在相同的地址空间中运行。 在其他模型中，共享内存用于共享数据结构和状态。 在所有三种模式中，数据必须从DBMS移到客户端。 这意味着所有的SQL请求都需要移入服务器进程，并且返回给客户端的所有结果都需要移出。 这是如何完成的？ 简单的答案是使用各种缓冲器。 两种主要类型是磁盘I / O缓冲区和客户端通信缓冲区。 我们在这里描述这些缓冲区，并简要讨论管理它们的策略。

​	**磁盘I / O缓冲区**：最常见的跨worker数据依赖性是对共享数据存储的读取和写入。 因此，DBMS工作者之间的I / O交互很常见。 有两种独立的磁盘I / O场景需要考虑：（1）数据库请求和（2）日志请求。

+ 数据库I / O请求：缓冲池。 所有持久性数据库数据都通过DBMS缓冲池进行缓存（第5.3节）。 对于 thread per worker中的worker，缓冲池只是一个在堆中存在的数据结构，可用在共享DBMS地址空间中的所有线程。 在另外两个模型中，缓冲池被分配到所有进程可用的共享内存中。 所有三种DBMS模型的最终结果是，缓冲池是可用于所有数据库线程和/或进程的大型共享数据结构。 当一个线程需要从数据库读入一个页面时，它会生成一个指定磁盘地址的I / O请求，以及缓冲池中可放置结果的空闲内存位置（帧）的句柄。 要将缓冲池页面刷新到磁盘，线程将生成一个I / O请求，该请求包含缓冲池中页面的当前帧和磁盘上的目标地址。 缓冲池在第4.3节中有更详细的讨论。

+ 日志I / O请求：日志跟踪(log tail)。数据库日志（第6.4节）是存储在一个或多个磁盘上的一组条目。由于日志条目是在事务处理期间生成的，因此它们被暂存到内存中的队列，该队列按照FIFO顺序定期刷新到日志磁盘。该队列通常称为日志跟踪。在许多系统中，单独的进程或线程负责定期将日志尾部清理到磁盘。

  ​	使用thread per worker模型，日志追踪就是一个堆中的数据结构。在另外两种模式中，两种不同的设计方案很常见。在一种方法中，一个单独的进程管理日志。日志记录通过共享内存或任何其他高效的进程间通信协议与日志管理器通信。在另一种方法中，日志追踪在共享内存中分配的方式与上面处理缓冲池的方式大致相同。关键在于执行数据库客户端请求的所有线程和/或进程都需要能够请求写入日志记录并刷新日志追踪。

  ​	一个重要的日志刷新类型是commit事务刷新。在commit日志记录刷新到日志设备之前，不能将事务报告为成功提交。这意味着客户端代码会一直等到提交日志记录被刷盘，并且DBMS服务器代码也必须持有所有资源（例如，锁），直到刷盘。日志刷盘请求可能会被推迟一段时间，以允许在单个I / O请求（“group commit”）中批量提交记录。

​	**客户端通信缓冲区**：通常在“pull”模型中使用SQL：客户端通过重复发出SQL FETCH请求来从查询游标中获取结果元组，该SQL FETCH请求会根据请求检索一个或多个元组。大多数DBMS尝试在FETCH请求流之前工作，以便在客户端请求之前准备好结果。

为了支持这种预取行为，DBMS工作者可以使用客户端通信套接字作为它产生的元组的队列。更复杂的方法实现客户端游标缓存，并使用DBMS客户端存储可能在不久的将来被取回的结果，而不是依赖于OS通信缓冲区。

​	**锁定表**：锁定表由所有DBMS worker共享，并由lock manager（第6.3节）用于实现数据库锁定语义。用于共享锁表的技术与共享缓冲池的技术相同，并且可以使用这些相同的技术来支持DBMS实现所需的任何其他共享数据结构。

## 2.2 DBMS Thread

上一节提供了DBMS Process Model的简化描述。 我们假定了**高性能的OS线程是可用的**，并且**数据库管理系统将只针对单处理器系统**。 在本节的其余部分中，我们放宽第一个假设并描述对DBMS实现的影响。 下一节将讨论多进程和并行处理。

### 2.2.1 DBMS Thread

​	今天的大多数数据库管理系统都来自20世纪70年代的研究系统和20世纪80年代的商业化工作。 我们认为理所当然的标准操作系统特性在DBMS开发人员建立原始数据库系统时通常无法使用。 高效率，高规模的OS线程支持可能是其中最重要的。 直到20世纪90年代，OS才得到广泛实施，并且在实际存在的情况下，实现方式差异很大。 即使在今天，一些OS线程的实现也不能很好地扩展到足以支持所有DBMS工作负载。

​	因此，出于传统，可移植性和可伸缩性的原因，许多广泛使用的DBMS在其实现中不依赖于OS线程。 一些完全避免线程，并使用process per worker或者process pool的方式。 那些基于其他process model 实现的方案（thread per worker）需要针对那些没有好的内核线程实现的操作系统的解决方案。 解决这个问题的几个主要的DBMS采用的一种方法是实现他们自己的专有的轻量级线程包。 这些轻量级线程或DBMS线程取代了上一节中描述的OS线程的角色。 这些线程包中，每个DBMS thread管理其自己的状态，通过非阻塞异步接口执行所有可能的阻塞操作（例如I / O），并频繁地将控制权交给分派任务的调度者。

​	轻量级线程是一个古老的想法，并广泛用于user interface中的event-loop编程。这种架构提供了快速任务切换和移植的简便性，代价是在DBMS中复制了大量的操作系统逻辑（任务切换，线程状态管理，调度等）[86]。

## 2.3 标准实现

在今天的领先数据库管理系统中，我们发现了第2.1节介绍的所有三种体系结构的代表以及其中一些有趣的变化。在这个层面上，IBM DB2可能是最有兴趣的例子，因为它支持四种不同的Process Model。在具有良好线程支持的操作系统上，DB2默认为thread per worker，并可选择支持在线程池复用worker。当在没有scalable thread 支持的操作系统上运行时，DB2默认为process per worker，并且可选地支持在进程池复用worker。
总结IBM DB2，MySQL，Oracle，PostgreSQL和Microsoft SQL Server支持的流程模型：

**process per worker**：
这是最直接的Process Model，今天仍然被大量使用。 DB2默认为在不支持高质量，可伸缩操作系统线程的操作系统上运行每个DBMS工作程序，并在每个DBMS工作线程上运行线程。这也是默认的Oracle方案。 Oracle还支持如下所述的process pool作为可选模型。 PostgreSQL为process per worker。

**thread per worker**：有两个变体

1. os thread per worker：在具有良好OS线程支持的系统上运行时，IBM DB2默认使用此模型，这是MySQL使用的模型。
2. dbms thread per worker：在此模型中，DBMS worker由OS进程或OS线程上的轻量级线程调度程序调度。该模型避免了任何潜在的操作系统调度程序扩展或性能问题，代价是实现成本高，开发工具支持较差以及DBMS供应商需要后期的软件维护。这个模型有两个主要的子类别：
   1. 在OS进程上调度的DBMS线程：轻量级线程调度程序由一个或多个OS进程托管。 Sybase和Informix一样支持这种模式。所有使用此模型的当代系统都实现了一个DBMS线程调度程序，该调度程序通过多个OS进程调度DBMS工作程序以利用多个处理器。但是，并非所有使用此模型的DBMS都实现了线程迁移（thread migration  ）：能够将现有DBMS线程重新分配给不同的OS进程（例如，用于负载平衡）。
   2. 在OS线程上调度的DBMS线程：Microsoft SQL Server支持将此模型作为非默认选项（默认情况是DBMS工作线程在下面描述的线程池上进行多路复用）。这种称为Fibers的SQL Server选项，用于某些高级事务处理基准测试，但否则使用相当少。

**process pool/thread pool：**
在此模型中，DBMS工作人员通过一系列进程进行复用。随着OS线程支持的改进，该模型的第二种变体已经基于线程池而不是进程池出现。在后一种模式中，DBMS工作人员通过OS线程池进行复用：

1. DBMS workers multiplexed over a process pool 

   该模型比process per worker具有更高的内存利用率，可以在没有良好OS线程支持的情况下轻松移植到OS，并且可以很好地扩展到大量用户。这是Oracle支持的可选模型，以及它们为具有大量同时连接的用户的系统所推荐的模型。 Oracle默认模型是process per worker。 Oracle支持的两种选项很容易支持它们定位的大量不同操作系统（Oracle支持的目标操作系统超过80种）。

2. DBMS workers multiplexed over a thread pool 

  Microsoft SQL Server默认使用此模型，超过99％的SQL Server安装以此方式运行。为了有效地支持数以万计的并发连接用户，如上所述，SQL Server可以选择支持在OS线程上调度的DBMS线程。
  正如我们在下一节中讨论的，大多数当代商用DBMS支持查询内并行：能够并行地在多个处理器上执行全部或部分单个查询。查询内并行性是将多个DBMS工作者临时分配给单个SQL查询。除了单个客户端连接可能有多个worker来执行之外，其他任何方式都不会影响底层的Process Model。

## 2.4 准入控制

在本章的结尾，我们阐述一下并发访问中剩下的一个问题。 随着任何多用户系统中的工作负载增加，吞吐量将增加到某个最大值。 超过这个点，随着系统开始抖动，它吞吐量将开始大幅下降。 与OS一样，性能抖动往往是内存压力的结果。DBMS不能将缓冲池中的数据库页面的“工作集”保留下来，并且花费所有时间来做页面替换。在DBMS中，查询处理技术尤其是排序和散列连接等查询处理技术会消耗大量内存。在某些情况下，由于争用锁也可能发生DBMS抖动：事务之间不断发生死锁，需要回滚并重新启动。因此，任何好的多用户系统都有一个**准入控制策略**，除非有足够的DBMS资源可用，否则它不接受新的工作。通过良好的准入控制器，系统将在过载情况下显示优雅的**降级**：**交易延迟将随着到达率成比例地增加，但吞吐量将保持在峰值。**

DBMS的准入控制可以在两层完成。首先，简单的准入控制策略可能在调度程序过程中，以确保客户端连接的数量保持在阈值以下。这用于防止像网络连接这样的基本资源过度消耗。在某些DBMS中，假设它是由另一个多层系统处理的，例如应用程序服务器，事务处理监视器或Web服务器。

​	第二层准入控制必须直接在核心DBMS关系查询处理器内实现。这个准入控制器的执行在查询被分析和优化之后，并确定查询是否被推迟，而后或者以更少的资源开始执行，或者没有资源限制的执行。准入控制器的执行由查询优化器提供的信息来辅助，该信息用于估计查询将需要的资源以及系统资源的当前可用性。特别是，优化器的查询计划可以指定（1）查询将访问的磁盘设备，以及每个设备的随机和顺序I / O数量的估计；（2）基于查询计划中的操作符和要处理的元组数量估计的查询的CPU负载；最重要的是（3）有关查询数据结构的内存占用情况的估计，包括用于在连接和其他查询执行任务期间对大量输入进行排序和散列的内存空间。如上所述，**这个最后的度量通常是准入控制器的关键**，因为内存压力通常是抖动的主要原因。因此，许多DBMS使用**内存占用量**和**活动worker**作为准入控制的主要标准。

## 2.5 额外讨论

Process Model的选择对DBMS的可扩展性和可移植性具有重大影响。因此，三个更广泛使用的商业系统在其产品线上支持多个process model。从工程角度来看，在所有操作系统和所有级别上采用单一的process model显然会更简单。但是，由于使用场景的多样性和目标操作系统的不一致性，这三个商业DBMS中的每一个都选择支持多个实现方式。

​	展望未来，由于硬件瓶颈的变化以及因特网负载的规模和多变性，近年来，服务器系统的新Process Model引起了人们的极大兴趣。这些设计中出现的一个主题是将服务器系统分解为一组独立调度的“引擎”，并在这些引擎之间异步传递消息。这就像上面的“进程池”模型，因为worker unit在多个请求中被重用。最近这项研究的主要创新之处在于，以比以前更小的任务指定方式，打破了系统功能的工作粒度。这导致了worker和SQL请求之间的多对多关系 - 通过多个工作者中的活动来处理单个查询，并且每个工作者针对许多SQL请求执行其自己的专用任务。这种架构可以实现更灵活的调度选择 - 例如，它允许动态权衡任务的执行方式，或者单个worker完成许多查询的任务（可能提高总体系统吞吐量），或着允许查询在多个worker中进行处理，进行动态权衡（以提高该查询的延迟）。在某些情况下，这已被证明在利用处理器高速缓存局部性方面具有优势，在cpu缓存没有命中的时候，能有效地减少CPU的闲置时间。在DBMS背景中中进一步研究这个想法的代表是StagedDB研究项目，可以进一步阅读。