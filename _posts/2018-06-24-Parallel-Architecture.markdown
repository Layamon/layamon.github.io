---
layout: post
title: 
date: 2018-05-25 13:59
header-img: "img/head.jpg"
categories: jekyll update
tags:
  - Paper
typora-root-url: ../../yummyliu.github.io
---

并行的硬件架构在现代服务器中是实际事实，并具有多种配置。 在本节中，我们总结标准DBMS中的术语，并讨论每个Process Model和内存的协调问题。

## Shared Memory

![](/image/shard-mem.png)

​	共享存储器并行系统是所有处理器都可以访问相同的RAM和性能大致相同的磁盘的的系统。这种体系结构现在非常标准 - 大多数服务器硬件都配备有2到8个处理器。高端机器可以装载数十个处理器，但相对于所提供的处理资源而言，这个价格有点偏高。高度并行的共享内存机器是硬件行业中最后剩下的“现金牛”之一，并且大量用于高端在线交易处理应用程序。服务器硬件的成本通常被这些系统的管理成本所拖垮，因此购买较少数量的大型非常昂贵的系统的费用有时被认为是可以接受的权衡（主要的管理成本就是雇佣DBA和SA，来配置管理数据库和操作系统）。

​	多核处理器支持单个芯片上的多个处理内核，并共享一些基础设施，如缓存和内存总线。这使得它们在编程模型方面与共享内存架构非常相似。今天，几乎所有关键的数据库的部署都基于多个处理器架构，每个处理器具有多个CPU。 DBMS体系结构需要能够充分利用这种潜在的并行性。幸运的是，Process Model中介绍的所有三种DBMS体系结构在现代共享内存硬件体系结构上运行良好。

​	共享内存机器的Process Model很自然地来自单处理器的方案。事实上，大多数数据库系统都是从最初的单处理器实现演变为共享内存实现。在共享内存机器上，操作系统通常支持跨处理器的worker（进程或线程）的透明分配，并且所有人都可以访问共享数据结构。所有这三个模型在这些系统上运行良好，并支持并行执行多个独立的SQL请求。主要的挑战是修改查询执行层以利用跨多个CPU并行化单个查询的能力;我们推迟到后面单独章节。

## Shared-Nothing

![](/image/shard-no.png)

​	Shared-Nothing并行系统（图3.2）由一组独立的机器组成，这些机器通过高速网络互连或越来越多地通过商用网络组件进行通信。其中任何节点无法直接访问另一个的内存或磁盘。

​	无共享系统不提供硬件共享抽象，使各种机器完全掌握在DBMS手中。 DBMS用来支持这些集群的最常用技术是在集群中的每台机器或节点上运行其标准进程模型。如上所述，每个节点都能够接受客户端SQL请求，访问必要的元数据，编译SQL请求以及执行数据访问，就像在单个共享内存系统上一样。主要区别在于群集中的每个系统只存储一部分数据。除了在本地执行sql查询外，还将请求发送到群集的其他成员，并且所涉及的所有计算机都针对它们存储的数据并行执行查询。这些表使用水平数据分区分布在集群中的多个系统上，以允许每个处理器独立于其他处理器执行。

​	数据库中的每个元组都分配给一台单独的机器，因此每个表格都“水平”切片并分布在机器上。典型的数据分区方案包括基于元组的散列分区，范围分区，循环以及范围和散列的组合。每个单独的机器负责访问，锁定和记录其本地磁盘上的数据。在查询执行过程中，查询优化器选择如何在整个机器上水平重新分区表和中间结果以满足查询，并为每台机器分配工作的逻辑分区。各个机器上的查询执行器将数据请求和元组相互传送，但不需要传送任何线程状态或其他底层信息。由于数据库元组基于值的分区，这些系统需要不需要复杂的合作。为了获得良好的性能，需要良好的数据分区。这给DBA带来了巨大的负担，无法智能地布置表，并且在查询优化器上做好工作量的分配工作。

​	这种简单的分区解决方案不能处理DBMS中的所有问题。例如，显式的多处理器协调必须完成，才能支持事务commit，负载均衡以及支持某些维护任务。例如，处理器必须为**分布式死锁检测**和**两阶段提交**等问题交换显式控制消息。这需要额外的逻辑，如果不谨慎，可能会成为性能瓶颈。

​	此外，存在部分失败的可能，必须在Shared-Nothing系统中进行管理。在共享内存系统中，a处理器的失败通常会导致整个机器关闭，从而导致整个DBMS关闭。在无共享系统中，单个节点的故障不一定会影响集群中的其他节点。但它肯定会影响DBMS的整体行为，因为失败的节点中托管数据库中的一小部分数据。在这种情况下至少有三种可能的方法。首先是如果任何节点失败，则关闭所有节点;这本质上模拟了共享内存系统中会发生什么。 Informix称为“数据跳过”的第二种方法允许在任何正在运行的节点上执行查询，以“跳过”失败节点上的数据。这在数据可用性比结果的完整性更重要的情况下很有用。但尽力而为的结果没有明确定义的语义，对于许多工作负载而言，这并不是一个有用的选择 - 尤其是因为DBMS通常用作多层系统中的“记录存储库”，而可用性和一致性权衡往往会在更高层次上完成（通常在应用程序服务器中）。第三种方法是采用冗余方案，从整个数据库故障转移（需要双倍的机器数量和软件许可证）到细粒度的冗余，如chained declustering。在后一种技术中，元组副本分布在集群中的多个节点上。与简单方案相比，chained declustering 的优势在于（a）它需要部署更少的机器来保证可用性;（b）当节点失败时，系统负载平均分配到其余节点：剩余的n - 1个节点每个都执行原始工作的n /（n-1），并且这种性能线性降级的形式会随着节点失败而继续下去。实际上，大多数当代的商业系统处于中间的某个位置，不管是完全数据库冗余的粗粒度，还是chained declustering 。

​	Shared-Nothing结构现在非常普遍，具有无与伦比的可扩展性和成本特性。它主要用于极端高端，通常用于决策支持应用程序和数据仓库。在硬件体系结构的有趣组合中，无共享集群通常由许多节点组成，每个节点都是共享内存多处理器。