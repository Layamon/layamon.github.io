---
layout: post
title: 
date: 2018-05-25 13:59
header-img: "img/head.jpg"
categories: jekyll update
tags:
  - Paper
typora-root-url: ../../yummyliu.github.io
---

并行的硬件架构在现代服务器中是实际事实，并具有多种配置。 在本节中，我们总结标准DBMS中的术语，并讨论每个Process Model和内存的协调问题。

## Shared Memory

![](/image/shard-mem.png)

​	共享存储器并行系统是所有处理器都可以访问相同的RAM和性能大致相同的磁盘的的系统。这种体系结构现在非常标准 - 大多数服务器硬件都配备有2到8个处理器。高端机器可以装载数十个处理器，但相对于所提供的处理资源而言，这个价格有点偏高。高度并行的共享内存机器是硬件行业中最后剩下的“现金牛”之一，并且大量用于高端在线交易处理应用程序。服务器硬件的成本通常被这些系统的管理成本所拖垮，因此购买较少数量的大型非常昂贵的系统的费用有时被认为是可以接受的权衡（主要的管理成本就是雇佣DBA和SA，来配置管理数据库和操作系统）。

​	多核处理器支持单个芯片上的多个处理内核，并共享一些基础设施，如缓存和内存总线。这使得它们在编程模型方面与共享内存架构非常相似。今天，几乎所有关键的数据库的部署都基于多个处理器架构，每个处理器具有多个CPU。 DBMS体系结构需要能够充分利用这种潜在的并行性。幸运的是，Process Model中介绍的所有三种DBMS体系结构在现代共享内存硬件体系结构上运行良好。

​	共享内存机器的Process Model很自然地来自单处理器的方案。事实上，大多数数据库系统都是从最初的单处理器实现演变为共享内存实现。在共享内存机器上，操作系统通常支持跨处理器的worker（进程或线程）的透明分配，并且所有人都可以访问共享数据结构。所有这三个模型在这些系统上运行良好，并支持并行执行多个独立的SQL请求。主要的挑战是修改查询执行层以利用跨多个CPU并行化单个查询的能力;我们推迟到后面单独章节。

## Shared-Nothing

![](/image/shard-no.png)

​	Shared-Nothing并行系统（图3.2）由一组独立的机器组成，这些机器通过高速网络互连或越来越多地通过商用网络组件进行通信。其中任何节点无法直接访问另一个的内存或磁盘。

​	无共享系统不提供硬件共享抽象，使各种机器完全掌握在DBMS手中。 DBMS用来支持这些集群的最常用技术是在集群中的每台机器或节点上运行其标准进程模型。如上所述，每个节点都能够接受客户端SQL请求，访问必要的元数据，编译SQL请求以及执行数据访问，就像在单个共享内存系统上一样。主要区别在于群集中的每个系统只存储一部分数据。除了在本地执行sql查询外，还将请求发送到群集的其他成员，并且所涉及的所有计算机都针对它们存储的数据并行执行查询。这些表使用水平数据分区分布在集群中的多个系统上，以允许每个处理器独立于其他处理器执行。

​	数据库中的每个元组都分配给一台单独的机器，因此每个表格都“水平”切片并分布在机器上。典型的数据分区方案包括基于元组的散列分区，范围分区，循环以及范围和散列的组合。每个单独的机器负责访问，锁定和记录其本地磁盘上的数据。在查询执行过程中，查询优化器选择如何在整个机器上水平重新分区表和中间结果以满足查询，并为每台机器分配工作的逻辑分区。各个机器上的查询执行器将数据请求和元组相互传送，但不需要传送任何线程状态或其他底层信息。由于数据库元组基于值的分区，这些系统需要不需要复杂的合作。为了获得良好的性能，需要良好的数据分区。这给DBA带来了巨大的负担，无法智能地布置表，并且在查询优化器上做好工作量的分配工作。

​	这种简单的分区解决方案不能处理DBMS中的所有问题。例如，显式的多处理器协调必须完成，才能支持事务commit，负载均衡以及支持某些维护任务。例如，处理器必须为**分布式死锁检测**和**两阶段提交**等问题交换显式控制消息。这需要额外的逻辑，如果不谨慎，可能会成为性能瓶颈。

​	此外，存在部分失败的可能，必须在Shared-Nothing系统中进行管理。在共享内存系统中，a处理器的失败通常会导致整个机器关闭，从而导致整个DBMS关闭。在无共享系统中，单个节点的故障不一定会影响集群中的其他节点。但它肯定会影响DBMS的整体行为，因为失败的节点中托管数据库中的一小部分数据。在这种情况下至少有三种可能的方法。首先是如果任何节点失败，则关闭所有节点;这本质上模拟了共享内存系统中会发生什么。 Informix称为“数据跳过”的第二种方法允许在任何正在运行的节点上执行查询，以“跳过”失败节点上的数据。这在数据可用性比结果的完整性更重要的情况下很有用。但尽力而为的结果没有明确定义的语义，对于许多工作负载而言，这并不是一个有用的选择 - 尤其是因为DBMS通常用作多层系统中的“记录存储库”，而可用性和一致性权衡往往会在更高层次上完成（通常在应用程序服务器中）。第三种方法是采用冗余方案，从整个数据库故障转移（需要双倍的机器数量和软件许可证）到细粒度的冗余，如chained declustering。在后一种技术中，元组副本分布在集群中的多个节点上。与简单方案相比，chained declustering 的优势在于（a）它需要部署更少的机器来保证可用性;（b）当节点失败时，系统负载平均分配到其余节点：剩余的n - 1个节点每个都执行原始工作的n /（n-1），并且这种性能线性降级的形式会随着节点失败而继续下去。实际上，大多数当代的商业系统处于中间的某个位置，不管是完全数据库冗余的粗粒度，还是chained declustering 。

​	Shared-Nothing结构现在非常普遍，具有无与伦比的可扩展性和成本特性。它主要用于极端高端，通常用于决策支持应用程序和数据仓库。在硬件体系结构的有趣组合中，无共享集群通常由许多节点组成，每个节点都是共享内存多处理器。

## Shared-Disk

![](/image/shared-disk.png)

Shared-Disk并行架构（图3.3）是所有处理器都可以以相同性能访问磁盘，但无法访问彼此的RAM。这种架构在Oracle RAC和DB2 for zSeries SYS-PLEX两个突出的例子中很常见。随着存储区域网络（SAN）的日益普及，近年来共享磁盘变得越来越普遍。 SAN允许一个或多个主机系统安装一个或多个逻辑磁盘，从而轻松创建共享磁盘配置。

​	Shared-disk比shared-nothing的一个潜在优势是它们的管理成本较低。共享磁盘系统的DBA不必考虑跨计算机的分区表以实现并行性。但是非常大的数据库通常仍然需要分区，所以在这种规模下，差异变得不那么明显。共享磁盘架构的另一个引人注目的特性是单个DBMS处理节点的故障不会影响其他节点访问整个数据库的能力。这与作为shared-memory整体失效和在节点故障时至少会丢失某些数据的shared-nothing（除非使用某种备用数据冗余方案）形成对比。但是，即使有这些优势，共享磁盘系统仍然容易受到某些单点故障的影响。如果数据在到达存储子系统之前被硬件或软件故障损坏或损坏，则系统中的所有节点将只能访问此损坏的页面。如果存储子系统使用RAID或其他数据冗余技术，则损坏的页面将被冗余存储，但仍会在所有副本中损坏。

​	由于在共享磁盘系统中不需要对数据进行分区，因此可以将数据复制到RAM中并在多台计算机上进行修改。与共享内存系统不同，没有自然的内存位置来协调数据的共享 - 每台计算机都有自己的本地内存用于锁定和缓冲池页面。因此需要在机器之间进行数据共享的明确协调。共享磁盘系统依赖于**分布式锁管理器**工具和用于管理分布式缓冲池的**高速缓存一致性协议**。这些是复杂的软件组件，并且可能成为存在重大争用的工作负载的瓶颈。某些系统（如IBM zSeries SYSPLEX）在硬件子系统中实施锁管理器。

## NUMA 

​	非统一内存访问（NUMA）系统通过具有独立内存的系统集群提供共享内存编程模型。集群中的每个系统都可以快速访问自己的本地内存，而跨高速集群互连的远程内存访问则有所延迟。架构名称来自内存访问时间的不均匀性

​	NUMA硬件架构是无共享和共享内存系统之间的有趣中间地带。它们比无共享集群更容易编程，并且通过避免诸如共享存储器总线之类的共享点竞争，扩展到比共享存储器系统更多的处理器。

​	NUMA集群在商业上并未广泛成功，但NUMA设计概念采用的一个领域是共享内存多处理器（第3.1节）。随着共享内存多处理器已经扩展到大量的处理器，它们的内存架构暴露出更频繁的不均匀性。通常，大型共享存储器的多处理器的存储器被划分为多个部分，并且每个部分与系统中的一小部分处理器相关联。内存和CPU的每个组合子集通常被称为一个pod。每个处理器可以比远程pod内存更快地访问本地pod内存。 NUMA设计模式的这种使用允许共享内存系统扩展到大量的处理器。因此，NUMA共享内存多处理器现在非常普遍，而NUMA集群从未取得任何显着的市场份额。

​	DBMS可以在NUMA共享内存系统上运行的一种方式是忽略内存访问的不一致性。这项工作可以接受的不均匀性很小。当近内存与远内存访问时间的比率超过1.5：1至2：1范围时，DBMS需要采用优化来避免严重的内存访问瓶颈。这些优化有多种形式，但都遵循相同的基本方法：

+ 当为处理器使用分配内存时，使用该处理器的本地内存（避免使用远存储器）
+ 如果可能的话，确保DBMS worker总是在与之前相同的硬件处理器上进行调度。

这种组合使得DBMS工作负载能够在高规模NUMA的共享内存系统上运行。虽然NUMA集群几乎消失了，但编程模型和优化技术对当代DBMS系统仍然很重要，因为许多高规模共享内存系统在其内存访问性能方面存在显着的不一致性。

## DBMS Threads 和 Multi-processors 

当我们从第2.1节中删除了最后两个简单假设时，一个使用DBMS线程的DBMS worker实现线程时出现的一个潜在问题就变得很明显，那就是单处理器硬件。 2.2.1节中描述的轻量级DBMS线程包的自然实现是所有线程在单个OS进程中运行的。不幸的是，一次只能在一个处理器上执行单个进程。因此，在多处理器系统上，DBMS一次只能使用一个单处理器，并会使系统的其余部分空闲。早期的Sybase SQL Server体系结构受到这种限制。随着共享内存多处理器在90年代初变得越来越流行，Sybase很快对架构进行了修改，以利用多个OS进程。

​	当在多个进程中运行DBMS线程时，有时会有一个进程拥有大量工作和其他进程（因此处理器）处于空闲状态。为了使这个模型在这些情况下很好地工作，DBMS必须实现进程之间的线程迁移。从6.0版本开始，Informix在此方面做得非常出色。

​	将DBMS线程映射到多个OS进程时，需要决定要使用多少个OS进程，如何将DBMS线程分配给OS线程以及如何在多个OS进程之间分配。一个好的经验法则是每个物理处理器有一个进程。这最大限度地提高了硬件固有的物理并行性，同时最大限度地减少了每进程内存开销。

## Standard Practice 

​	关于对并行性的支持，趋势与上一节相似：大多数主要DBMS支持多种并行性模式。由于共享内存系（SMP，多核系统以及两者的组合）的商业流行，共享内存并行性得到了所有主要DBMS供应商的很好支持。我们开始看到支持的差异在于多节点集群并行性，其中广泛的设计选择是shared-disk和shared-nothing。

+ Shared-momery：所有主要商业DBMS提供程序都支持共享内存并行机制，包括：IBM DB2，Oracle和Microsoft SQL Server。
+ Shared-Nothing：该模型由IBM DB2，Informix，Tandem和NCR Teradata等提供支持; Greenplum提供了支持的PostgreSQL自定义版本支持shared-nothing的并行性。
+ shared-disk：此模型由Oracle RAC，RDB支持（由Oracle从Digital Equipment Corp 收购）以及IBM DB2 for zSeries等。

IBM销售多种不同的DBMS产品，并选择在某些产品中实现shared-disk支持，而其他产品则不提供共享。到目前为止，没有一家领先的商业系统在单一代码中同时支持shared-nothing和shared-disk； Microsoft SQL Server也没有实现。

## 其他讨论和材料

上面的设计代表了各种服务器系统中使用的硬件/软件架构模型的选择。虽然他们在数据库管理系统方面的开创性很大，但这些想法在其他数据密集型领域日益普及，其中包括像Map-Reduce这样的更低级别的可编程数据处理后端，这些后端正在成为各种定制数据分析任务的增加用户。但是，即使这些想法正在更广泛地影响计算，在数据库系统的并行设计中也会出现新的问题。

​	并行软件体系结构在未来十年的一个关键挑战来自于希望利用来自处理器供应商的新一代“多核”体系结构。这些器件将引入新的硬件设计点，在单芯片上具有数十个，甚至数千个处理单元，通过高速片上网络进行通信，但保留了关于片外存储器和磁盘访问方面的许多现有瓶颈。这将导致磁盘和处理器之间的内存路径出现新的不平衡和瓶颈，这几乎肯定需要重新审查DBMS体系结构以满足硬件的性能潜力。

​	在面向服务的计算领域，我们预见到一个更加“宏观”的规模的相关架构转变。这里的想法是拥有数万台计算机的大型数据中心将为用户提供处理（硬件和软件）。在这种规模下，应用和服务器管理只有在高度自动化的情况下才能承受，不能人工管理这种规模的服务器。而且，由于通常使用的可靠性较差的商品服务器，并且故障较为常见，因此需要完全自动化从常见故障中恢复。在这种环境中，每天会出现磁盘故障，每周有几次服务器故障。在此环境中，数据库备份通常由存储在不同服务器磁盘上的整个数据库的冗余联机副本取代。根据数据的大小，冗余副本甚至可以存储在不同的数据中心。自动离线备份仍可用于从应用程序，管理或用户错误中恢复。但是，从大多数常见错误和故障中恢复是基于冗余联机副本的快速故障切换。可以通过多种方式实现冗余：

+ 在数据存储级（存储区网络）复制，
+ 在数据库存储引擎级进行数据复制（如后章节所述）
+ 冗余执行
+ 在客户端软件级别（例如，通过网络服务器或应用程序服务器）自动生成的冗余数据库请求。

​	在一个解耦的层面上，实践中多个具有DBMS功能的服务器按层次部署是非常常见的，目的是尽量减少对“DBMS记录”的I / O请求率。这些方案包括各种形式的用于SQL查询的中间层数据库缓存，包括专门的内存数据库（如Oracle TimesTen）以及配置用于此目的的更传统的数据库。在部署堆栈中的位置越来越高，许多面向对象的应用程序服务器体系结构（支持Enterprise Java Beans等编程模型）可以配置为与DBMS一起对应用程序对象进行事务性缓存。然而，这些不同方案的选择，设置和管理仍然不够标准和复杂，优雅的普遍认可的模型仍然难以捉摸。