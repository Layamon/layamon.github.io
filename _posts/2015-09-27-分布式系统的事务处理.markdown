---
layout: post
title:  "分布式系统的事务处理"
subtitle: 分布式系统的一致性，需要分布式事务解决，如何实现分布式的事务处理是分布式计算的一门学问
date:   2015-09-27 18:00
categories: jekyll update
tags:
    - Program
---

### 分布式处理事务要解决的问题

单台服务器不足以解决现在的网络请求的，需要扩展现在的服务

+ 数据分区
+ 数据镜像

**高可用性要求只能通过第二种方法来实现——数据冗余存储**，而使用数据冗余存储，又会带来一致性的问题，一致性的问题的解决又会带来性能的问题，所以我们重点考虑以下几个问题：

+ 容灾：数据不丢，结点的failover
+ 数据一致性：事务处理
+ 性能： 吞吐量，响应时间

> 数据副本是分布式系统解决数据丢失异常的唯一手段。

### 一致性模型 

+ 弱一致性：当你写一个新值后，读操作在数据副本上可能读出来，也可能读不出来
+ 最终一致性：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。DNS 电子邮件 Amazon S3，Google搜索引擎。
+ 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如文件系统，RDBMS，Azure Table

> 从三种一致性模型上来说，前两种一般是异步冗余的，Strong是同步冗余的，下面由浅入深，看看哪些技术：

#### Master-Slave

在这种架构中，Slave 一般是Master的备份，一般是如下设计的：

+ 读写请求都由Master负责
+ 写请求写到Master上后，由Master同步到Slave上

从Master同步到Slave，可以使用Master来push，可以使用Slave来pull，**通常是采用Slave来周期性的pull**，所以是最终一致性，存在的问题是Master在pull周期内垮掉了，会导致这个时间片内的数据丢失，如果不想丢，Slave只能Read-Only的方式等Master恢复。

#### Master-Master

系统中存在多个Master，每个Master都提供read-write服务，数据间的同步通过Master间的异步完成，所以是最终一致性。
但多个Master对同一个数据进行修改的时候，这个模型的噩梦就出现了——对数据间的冲突的合并。

#### Two/Three Phase Commit

两阶段提交，在分布式系统中每个节点无法得知其他节点成功与否，当一个事物跨越多个节点的时候，为了保持事物的ACID特性，需要引入一个作为*协调者*的组件来统一掌握所有节点（*参与者*）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交：

##### 第一阶段：vote
1. 协调者问所有参与者节点是否可以提交操作。
2. 各个参与者开始事务执行的准备工作；如为资源上锁，预留资源，写undo/redo log...
3. 参与者相应协调者，准备工作成功，回应『可以提交』否则『拒绝提交』

##### 第二阶段：decision
+ 如果所有参与者都回应可以提交，那么协调者向所有的参与者发送『正式提交』的命令，参与者完成正式提交，并释放所有资源，然后回应『完成』，协调者收集各个几点的『完成』回应后，结束这个 Global Tranaction
+ 如果有一个参与者回应『拒绝提交』，那么，协调者向所有的参与者发送『回滚操作』。并释放所有资源，然后回应『回滚完成』，协调者收集各个节点的回滚回应后，取消这个Global Transaction。

> 可以看到这个2PC,是一个强一致性的算法，在一些系统设计中，会串联一些调用，每一步调用都要分配一些资源或改写一些数据，使用**try->confirm**的方式来确保整个流程能够成功完成。
> 另外我们可以看到其中存在的一些问题：
+ 其中一个是同步阻塞操作，必然会影响性能
+ 另一个问题在timeout上：在系统中如果是 协调者发的信息参与者回应超时，协调者可以选着重发，或者把其视为问题节点，剔除集群；但若是协调者崩了，参与者收不到协调者的指令，所有参与者将处在不知所措的状态；比如最大的问题就是在**第一阶段完成后，参与者在第二阶段没有收到决策，那么数据节点会进入『不知所措』的状态，这个状态会block住整个事物**。

所以，Coordinator的可用性是个关键，因此，我们引入三段提交，把2pc的第一阶段拆成两个阶段，先询问，再锁资源，最后提交。**在询问的时候不锁资源，除非所有人同意了才开始锁资源**

这样在precommit后，如果发生了F/T的问题，比起2pc，3pc可以继续直接把状态变成Commit

> timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所适从，你也不知道对方是做了还是没有做，于是状态机就因为timeout成了摆设

#### Paxos算法

> 该算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生一上任何异常都不会破坏决议的一致性。
> 一个典型的场景，在一个分布式数据库系统中，如果各个节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态，为保证灭个节点都执行相同的操作序列，需要在每条指令上执行一个『一致性算法』以保证每个节点看到的指令一致。

Paxos的目的是让整个集群的节点对某个值的变更达成一致。任何一个点都可以提出修改这个数据的提案，是否通过取决于这个集群中是否有超过半数的节点的同意（所以要求集群的阶段是单数）。

详细算法，见下一篇。。。


