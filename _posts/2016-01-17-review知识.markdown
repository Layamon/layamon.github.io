---
layout: post
title: review知识
date: 2016-01-17 13:34
categories: jekyll update
tags:
    - 数据结构
---


## 数据库实现原理与数据库demo及pg源码

> 标题有点大,感觉做的事情是偏存储的，但是并发事物的处理也应该看看

### 查询处理 
    
##### 四个数据结构
    1. sql query
    2. relational-algebra expression or a parse tree
    3. execution plan
    4. query output
##### 三个转换过程
    1. parser and translator
    2. optimizer
    3. execution engine

##### 操作符们

    个人理解：**排序 b树索引 hash索引，这是操作符的主要实现方式，b树是和磁盘相适应的索引结构用来实现聚集索引，hash更多的用来解决内存不足的时候，来分块解决问题时，就用hash分成互相独立的子问题**

    1. selection operation

> 主要考虑 磁盘io的开销，分为 ts : 定位磁盘块的时间，tt : 传输磁盘块的时间，并且定位的时间远大于传输的时间,基于定位时间远大于传输时间，我们在表的主键上一般有聚集索引，这样扫描表的时候，就按照顺序扫描，设表文件有 br 块

    + linear search ts+br*tt
    + binary search log2(br)*(ts+tt)
    + index scan , 主要是B树索引 又按照索引文件中的顺序和物理存储是否相同的分为 primary index(also referred to as a clustering index) ,secondary index; 这里分为 单个或者较小范围的查询，大范围的查询；如果是在primary index中那么就这样就可以了，如果是次级索引，因为其中只是存了record的指针，每次取的时候 都要去进行一次磁盘io，这个时候还不如用linear search 来的方便
    + complex selection : 就是where 后面有好多表达式，最后就可以表示成一个析取范式(conjunction) 或者 合取范式(disjunction)；对于conjunction来说，如果其中一个或多个属性上有单个或复合索引，那么就按照这个索引先找出符合这些索引上属性的记录，然后再由其他的条件来筛选；
    另外若是存在针对 record pointer 和 record identifiers 的索引,可以利用这个索引 来找到单个条件的记录，最后做交集(intersection)
    若是合取范式，如果每个条件的属性上都有索引，那么每个都找，否则有一个没有就要linear scan，这时候其他的索引也不要用了，就直接全表扫描就行了
    
    2. sorting
> 这里主要关注的是外排序,内排序quick sort等
    + 最著名的外排序算法就是 external sort-merge:
        1. 挨个读取关系表文件M块，在内存中将这M块拍好序之后，写到外存临时文件Ri
        2. 假设外存的临时文件数小于内存块数，并且还要留一个块作为输出，那么一块块的读取这些临时文件到内存，然后做merge
        
    3. inner join / equi join

    + nested-loop join
    + block nested-loop join
    + indexed nested-loop join
    + merge join
    + hash join
    
    4. duplicate elimination
    
    排序去重，hash去重

    5. projection 

    6. set ope
    
    + union
    + intersection
    + difference

    通过排序或者hash来解决

    7. outer join

    8. aggregation
    > sort or hash

##### 组合操作符产生结果
        
    1. materialization
        将每一步的结果都进行物化，成一个临时表，写入磁盘的时候 这里可以使用双缓冲区 进行简单优化，

    2. producer-driven pipeline
    
    + demand-driven pipeline : 位于执行计划树顶端的操作，需要tuple的时候，向下面的操作符上请求tuple，以此类推, pull from top, 在这个模型中每个operator 都可以作为一个实现一个iterator接口，提供 open next close 的操作
    + producer driven : 每个操作不断的产生操作结果放在一个缓冲区中，等上层的操作过来取，每取走一个就 删掉这个元组 push from bottom 
    + 使用pipeline的时候，某些join算法，比如sort-merge 需要在之前对关系进行排序，需要得到全部的tuple，这个时候pipeline就和其冲突了，所以针对pipeline相应的算法也要进行改变。
        主要是join算法：
            1). only one of the inputs to a join is pipelined
                其中一个有索引，那么pipe的表 就可以作为probe的
                或者两个是有序的，就可以merge
            2). Both inputs to the join are pipelined
                同样如果有序就好说
                否则有个pipeline-join 的算法，存好两个表所有元组在队列中，然后需要建立索引
