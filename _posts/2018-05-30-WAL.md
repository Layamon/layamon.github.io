---
layout: post
title: 深入认识PostgreSQL的WAL
subtitle: wal日志是PostgreSQL实现原子性和持久性的关键技术，并且基于wal实现了PostgreSQL的各种复制；
date: 2018-05-30 18:06
header-img: "img/head.jpg"
categories: jekyll update
tags:
    - PostgreSQL
---

* TOC
{:toc}

DB所处的运行环境有**随时崩溃**的可能，我们需要知道事务是成功还是失败的（atomic），事务一旦返回成功后，要确保事务进行的修改不会丢失（durability），但同时又需要良好的性能。

为了提高写入的性能， 数据库中往往会有一个缓冲区，来管理磁盘块数据的写入，其维护了磁盘块数据的一个副本，在内存中对数据进行更改，并将改过的页面标记为dirty，最后将脏页刷盘，这刷盘的过程就是checkpoint（见另一文）。

## 术语

当我们做db recovery的时候，有一个问题：PG从哪个点开始恢复的？就是REDOpoint，即，最近的checkpoint开始的时候写入的checkpoint record。checkpointer后台进程，间歇性的执行checkpoint。当checkpointer启动，它在current wal seg中写入一个checkpoint record，这条记录记录的最新的redo point；insert/delete/update。。。。的时候，将相应操作写成一个record，写入wal buffer中，并更新table page的header的lsn字段。当事务commit的时候，将commit语句写一个xlog record写入到 wal buffer中，并刷新到wal file中。当crash的时候，所有的share buffer中的更改丢失，但是wal中有所有commit的history data。

### REDO

包含数据库中所有改动后的值，在写数据文件之前先将值写入到redo日志中；主要用处有三个：

+ 异常恢复
+ 基于时间点的恢复
+ 数据库复制

> Undo日志记录某数据被修改前的值，可以用来在事务失败时进行rollback；

### WAL

PostgreSQL中的事务日志叫WAL（write ahead log）日志，在写数据文件之前先写入到wal中，是REDO日志。

> 和wal log对应的一种解决方案是：command logging ；比如mysql中记录的是执行的命令。

### LSN

Log Sequence Number，记录在日志中的位置。

### Clog 

Commit Log，记录事务状态，位于shared buffer的事务状态缓存区中。

## 恢复

通过pg_waldump可以看到wal中的信息。

```
$ pg_waldump 00000001000000020000005B | grep -E -v 'Standby|Transaction|Sequence|Btree|Heap' | head -n 1
rmgr: XLOG        len (rec/tot):    106/   106, tx:          0, lsn: 2/5B088928, prev 2/5B0888F0, desc: CHECKPOINT_ONLINE redo 2/5B0888F0; tli 1; prev tli 1; fpw true; xid 0:24389; oid 33250; multi 2; offset 3; oldest xid 548 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 24084; online
```

PostgreSQL的WAL是保证持久化到磁盘中的，并有变更的详细描述，所以在crash之后，可以根据log进行恢复，如下：

1. 当POstgreSQL启动的时候，检查pg_control中的state字段，如果该字段是 in production; PostgreSQL进入recovery-mode，因为PostgreSQL没有正常结束；如果是shut down, 那么进入startup-mode;
2. 从pg_control读取最新的checkpoint记录，从记录了checkpoint的xlog record中读取到redo point；进行恢复，如果该checkpoint损坏，从pg_control读取prior checkpoint（PG11中将不会存储这个信息）；
3. 开始恢复（non-backup block中的redo 操作不是幂等的，所以要按照xlog的lsn大小，顺序恢复）；

### 普通恢复

1. PostgreSQL的每个page的header上有最后更新的lsn，将page和xlog的record读取到内存中。

2. PostgreSQL比较xlog record的lsn和table page的lsn：如果xlog record比较大，那么应用这个record，并修改page的lsn；否则，不做操作

3. 将左右的xlog record都重放一下，重放的时候按照rmgr对应的资源管理器（'Standby,Transaction，Sequence，Btree，Heap'）进行对应的操作；比如下例，对Heap资源进行恢复操作。

   ```
   rmgr: Heap        
   len (rec/tot):    175/   175, 
   tx:      24388, 
   lsn: 2/5B002070, 
   prev 2/5B0013B8, 
   desc: INSERT off 46, 
   blkref #0: rel 1663/13451/16498 blk 42
   ```

### 有full-page image的恢复：

1. PostgreSQL将xlog record和page读取到shard buffer中。
2. 当record时full-page image时，直接用full-page image覆盖这个page，并更新这个page的lsn；
3. 后续的非full-page的record的处理，和之前一样；

### 事务日志的分段存储

事务日志可以非常大，但是如果在一个文件里不方便管理，我们将事务日志切分为16Mb的segment；每个segment是一个24位的16进制数字，前八位是timelineid，中间8位和最后8位可以看做是 一个256进制的两位数：

当最后8位满0xFF进1的时候，中间8位+1；一次类推

> 通过pg_walfile_name函数，可以传入一个lsn值，得到该lsn对应的record在哪个wal中；
>
> ```sql
> postgres=# SELECT pg_walfile_name('2/5AFFF3A8');
>      pg_walfile_name
> --------------------------
>  00000001000000020000005A
> ```

一个16Mb的wal段，内部切分为8k大小的页；第一个页有一个header-data，其他的页的header定义为`XLogPageHeaderData`; 基于header的定义每个xlog record记录相应的record;

### DML操作的执行过程

比如执行了如下一个语句，内部函数exec_simple_query被执行：：

```sql
testdb=# INSERT INTO tbl VALUES ('A');
```

```c
exec_simple_query() @postgres.c

(1) ExtendCLOG() @clog.c                  /* 在CLOG中写入该事务的信息：
                                           * "IN_PROGRESS" .
                                           */
(2) heap_insert()@heapam.c                /* 插入一条tuple，创建一个xlog record,
                                           * 调用XLogInsert函数.
                                           */
(3)   XLogInsert() @xlog.c (9.5 or later, xloginsert.c)
                                          /* 把xlog record写入到 WAL buffer中，并更新page的											* pd_lsn.
                                           */
(4) finish_xact_command() @postgres.c     /* commit*/
      XLogInsert() @xlog.c  (9.5 or later, xloginsert.c)
                                          /* Write a XLOG record of this commit action
                                           * to the WAL buffer.
                                           */
(5)   XLogWrite() @xlog.c                 /* Write and flush all XLOG records on
                                           * the WAL buffer to WAL segment.
                                           */
(6) TransactionIdCommitTree() @transam.c  /* Change the state of this transaction
                                           * from "IN_PROGRESS" to "COMMITTED" on the CLOG.
```

## 管理

### Wal Writer进程

这个服务进程间歇的运行，将wal buffer刷新到磁盘上，主要是防止同时提交太多，导致磁盘IO过载；

### Checkpointer进程

当以下三种情况下，checkpoint进程启动：

1. 时间到了：

   `checkpoint_timeout`： 距离上次checkpoint过去了这些时间，默认5分钟

2. wal日志数量到了：

   + 9.4之前的配置了checkpoint_segment参数，默认是3，消费了这些wal segment，就会触发checkpoint
   + 9.5之后，总的walfile超过了`max_wal_size`；默认64个file 1GB

3. PostgreSQL在smart或者fast模式stop，start_basebackup

4. superuser，手动执行，checkpoint

### Wal段文件管理

#### 何时切换wal段文件

只要每次产生了一个新的wal，就执行archive_commond:

1. 满了
2. pg_switch_xlog
3. archive_mode = on且archive_timeout


#### 安全的删除wal

如果想要删除wal日志，要么让pg在CHECKPOINT的时候自己删除，或者使用`pg_archivecleanup`。除了以下三种情况，pg会自动清除不再需要的wal日志：

1. `archive_mond=on`，但是`archive_command`failed，这样pg会一直保留wal日志，直到重试成功。
2. `wal_keep_segments`需要保留一定的数据。
3. 9.4之后，可能会因为replication slot保留；

如果都不符合上述情况，我们想要清理wal日志，可以通过执行`CHECKPOINT`来清理当前不需要的wal。

在一些非寻常情况下，可能需要`pg_archivecleanup`命令，比如由于wal归档失败导致的wal堆积引起的磁盘空间溢出。你可能使用这个命令来清理归档wal日志，但是永远不要手动删除wal段；

#### 从归档wal中恢复

可以手动的将wal从归档复制回pg_xlog/pg_wal中，或者创建一个recovery.conf其中配置好restore_command来做这件事。
