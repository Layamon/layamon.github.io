---
layout: post
title: Nginx源码之进程管理
date: 2018-11-06 17:18
header-img: "img/head.jpg"
categories: jekyll update
tags:
  - nginx
typora-root-url: ../../yummyliu.github.io
---

* TOC
{:toc}

# Main

跟进程管理相关，有如下4个全局对象：

```c
typedef struct {
    ngx_pid_t           pid;
    int                 status;
    ngx_socket_t        channel[2];

    ngx_spawn_proc_pt   proc;
    void               *data;
    char               *name;

    unsigned            respawn:1;
    unsigned            just_spawn:1;
    unsigned            detached:1;
    unsigned            exiting:1;
    unsigned            exited:1;
} ngx_process_t;

ngx_int_t        ngx_process_slot; 	// ngx_processes数组的下标
ngx_socket_t     ngx_channel;		// ？worker监听的socket，这里叫channel
ngx_int_t        ngx_last_process;	// ngx_processes的最后一个元素
ngx_process_t    ngx_processes[NGX_MAX_PROCESSES];	// 全局process数组
```

通过监听channel上的command，来控制Nginx Proces；

```c
typedef struct {
     ngx_uint_t  command;
     ngx_pid_t   pid;
     ngx_int_t   slot;
     ngx_fd_t    fd;
} ngx_channel_t;

// command
#define NGX_CMD_OPEN_CHANNEL   1
#define NGX_CMD_CLOSE_CHANNEL  2
#define NGX_CMD_QUIT           3
#define NGX_CMD_TERMINATE      4
#define NGX_CMD_REOPEN         5
```

## Main Start

### Register Signal

> ngx_init_signals

利用sigaction 将全局信号对象`ngx_signal_t  signals`注册到系统中，在`ngx_signal_handler`对信号进行分发处理；

```c
ngx_signal_t  signals[] = {
    { ngx_signal_value(NGX_RECONFIGURE_SIGNAL),
      "SIG" ngx_value(NGX_RECONFIGURE_SIGNAL),
      "reload",
      ngx_signal_handler },

    { ngx_signal_value(NGX_REOPEN_SIGNAL),
      "SIG" ngx_value(NGX_REOPEN_SIGNAL),
      "reopen",
      ngx_signal_handler },
... ... 
```

`ngx_signal_handler`中按照ngx_process分别处理master和worker中的信号。

##### Register Signal

```c
    sigaddset(&set, SIGCHLD);
    sigaddset(&set, SIGALRM);
    sigaddset(&set, SIGIO);
    sigaddset(&set, SIGINT);
    sigaddset(&set, ngx_signal_value(NGX_RECONFIGURE_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_REOPEN_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_NOACCEPT_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_TERMINATE_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));
    sigaddset(&set, ngx_signal_value(NGX_CHANGEBIN_SIGNAL));
```

##### Start worker

> ngx_start_worker_processes

```
#define NGX_PROCESS_NORESPAWN     -1
#define NGX_PROCESS_JUST_SPAWN    -2
#define NGX_PROCESS_RESPAWN       -3
#define NGX_PROCESS_JUST_RESPAWN  -4
#define NGX_PROCESS_DETACHED      -5
```

按照配置的进程数，挨个启动worker

##### Spawn Process

> ngx_spawn_process

首先，在全局数组：ngx_processes中，创建一个slot，设置其中连接的channel[2]；

```c
int
     socketpair(int domain, int type, int protocol, int socket_vector[2]);

DESCRIPTION

     The socketpair() call creates an unnamed pair of connected sockets in the
     specified domain domain, of the specified type, and using the optionally
     specified protocol.  The descriptors used in referencing the new sockets
     are returned in socket_vector[0] and socket_vector[1].  The two sockets
     are indistinguishable.
```

最后，fork

# Master Loop

>  ngx_master_process_cycle

通过Main中注册的信号监听回调，当发生收到某些信号时，将设置如下全局状态对象

```c
sig_atomic_t  ngx_reap;
sig_atomic_t  ngx_sigio;
sig_atomic_t  ngx_sigalrm;
sig_atomic_t  ngx_terminate;
sig_atomic_t  ngx_quit;
sig_atomic_t  ngx_debug_quit;
ngx_uint_t    ngx_exiting;
sig_atomic_t  ngx_reconfigure;
sig_atomic_t  ngx_reopen;
```

在MasterLoop中，不断检查这些标志位，然后进行相应的操作，不同的操作会通过`ngx_signal_worker_processes`给worker发送不同的指令；写channel是调用如下函数，并且都是些channelp[0]。（前文知道，启动新worker的时候，相应的ngx_process有自己的channel，并且是通过socketpair创建的一个连接对）。

```c
ngx_write_channel(ngx_processes[n].channel[0],
```

# Worker Loop

假设：不同的worker上有自己的**长连接**，各自处理各自的请求；master不存在分发请求的需求，就像一开始

> ngx_process_events_and_timers

?? TODO





